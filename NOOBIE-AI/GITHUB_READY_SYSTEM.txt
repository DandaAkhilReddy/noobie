# NOOBIE AI - COMPLETE SYSTEM FOR GITHUB
# Repository: https://github.com/DandaAkhilReddy/noobie
# Generated by Claude Code

## üöÄ QUICK SETUP INSTRUCTIONS:
1. Go to: https://github.com/DandaAkhilReddy/noobie
2. Create new repository (public or private)
3. Copy each file below exactly as shown
4. Commit and your system is ready!

================================
FILE STRUCTURE TO CREATE:
================================

üìÅ Repository Root
‚îú‚îÄ‚îÄ üìù .gitignore
‚îú‚îÄ‚îÄ üìö README.md  
‚îú‚îÄ‚îÄ ‚úÖ NOOBIE_DEPLOYMENT_COMPLETE.md
‚îú‚îÄ‚îÄ üöÄ deploy_azure.sh
‚îú‚îÄ‚îÄ üìÅ claud_agent/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ config.py
‚îÇ   ‚îú‚îÄ‚îÄ logger.py
‚îÇ   ‚îú‚îÄ‚îÄ news_fetcher.py
‚îÇ   ‚îú‚îÄ‚îÄ blog_writer.py
‚îÇ   ‚îî‚îÄ‚îÄ github_publisher.py
‚îú‚îÄ‚îÄ üìÅ azure_function/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ function_app.py
‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt
‚îÇ   ‚îú‚îÄ‚îÄ host.json
‚îÇ   ‚îú‚îÄ‚îÄ local.settings.json
‚îÇ   ‚îú‚îÄ‚îÄ proxies.json
‚îÇ   ‚îú‚îÄ‚îÄ .funcignore
‚îÇ   ‚îî‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ üìÅ docs/
‚îî‚îÄ‚îÄ üìÅ tests/

================================
COPY EACH FILE BELOW:
================================

=== FILE: .gitignore ===
# NOOBIE AI - Git Ignore File
# ============================

# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# Virtual environments
venv/
env/
ENV/
env.bak/
venv.bak/
.venv/

# IDE
.vscode/
.idea/
*.swp
*.swo
*~
.DS_Store

# Azure Functions
.azure/
azure_function/local.settings.json
bin/
obj/

# Logs and cache
*.log
logs/
.cache/
blog_output/
news_cache_*.json

# Test coverage
.coverage
htmlcov/
.pytest_cache/
.tox/

# Secrets and API keys
*.key
*.pem
secrets.json
.env
.env.local
.env.production

# OS generated files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Backup files
*.bak
*.backup
*~

=== FILE: README.md ===
# NOOBIE AI - Automated Blog Generation System

## ü§ñ Overview

NOOBIE AI is a comprehensive, production-ready artificial intelligence system that automatically generates and publishes daily blog posts based on global news analysis. Built with enterprise-grade engineering standards, it combines multiple AI APIs, news sources, and automated publishing to create thoughtful, engaging content.

## ‚ú® Key Features

- **üîç Multi-Source News Aggregation**: Fetches from GNews API, RSS feeds, and Google News
- **ü§ñ AI-Powered Content Generation**: Uses Claude and OpenAI APIs for intelligent blog writing
- **üì§ Automated GitHub Pages Publishing**: Direct publishing with Jekyll optimization
- **‚è∞ Scheduled Automation**: Daily blog generation at 8:00 AM UTC via Azure Functions
- **üéõÔ∏è Manual Trigger Support**: HTTP endpoints for on-demand generation
- **üìä Production Logging**: Structured JSON logging with Azure Application Insights
- **üõ°Ô∏è Robust Error Handling**: Retry logic, fallbacks, and comprehensive monitoring
- **üé≠ Mock Mode**: Testing capabilities with generated content

## üèóÔ∏è Architecture

```
claud-agent/
‚îú‚îÄ‚îÄ claud_agent/           # Core Python package
‚îÇ   ‚îú‚îÄ‚îÄ config.py          # Configuration management
‚îÇ   ‚îú‚îÄ‚îÄ logger.py          # Advanced logging system
‚îÇ   ‚îú‚îÄ‚îÄ news_fetcher.py    # Multi-source news aggregation
‚îÇ   ‚îú‚îÄ‚îÄ blog_writer.py     # AI-powered content generation
‚îÇ   ‚îî‚îÄ‚îÄ github_publisher.py # GitHub Pages publishing
‚îú‚îÄ‚îÄ azure_function/        # Serverless automation
‚îÇ   ‚îú‚îÄ‚îÄ function_app.py    # Azure Functions entry points
‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt   # Dependencies
‚îÇ   ‚îú‚îÄ‚îÄ host.json         # Function configuration
‚îÇ   ‚îî‚îÄ‚îÄ local.settings.json # Development settings
‚îú‚îÄ‚îÄ tests/                 # Comprehensive test suite
‚îú‚îÄ‚îÄ docs/                  # Documentation
‚îî‚îÄ‚îÄ deploy_azure.sh       # Deployment automation
```

## üöÄ Quick Start

### Prerequisites

1. **Python 3.9+** with pip
2. **Azure Account** with Functions support
3. **GitHub Account** with repository access
4. **API Keys**:
   - GNews API key ([gnews.io](https://gnews.io))
   - Claude API key ([anthropic.com](https://anthropic.com))
   - OpenAI API key ([openai.com](https://openai.com)) (optional)
   - GitHub Personal Access Token

### Local Development

1. **Clone and Setup**:
   ```bash
   git clone https://github.com/akhilreddydanda/NOOBIE.git
   cd NOOBIE/claud-agent
   python -m venv venv
   source venv/bin/activate  # On Windows: venv\Scripts\activate
   pip install -r azure_function/requirements.txt
   ```

2. **Configure Environment**:
   ```bash
   # Copy and edit local settings
   cp azure_function/local.settings.json.example azure_function/local.settings.json
   
   # Add your API keys
   export NEWS_API_KEY="your_gnews_api_key"
   export CLAUDE_API_KEY="your_claude_api_key" 
   export GITHUB_TOKEN="your_github_token"
   export GITHUB_REPO="username/repository"
   ```

3. **Test Locally**:
   ```bash
   cd azure_function
   func start --python
   
   # Test endpoints
   curl http://localhost:7071/api/health
   curl -X POST http://localhost:7071/api/manual_generate
   ```

### Azure Deployment

1. **Automated Deployment**:
   ```bash
   chmod +x deploy_azure.sh
   ./deploy_azure.sh
   ```

2. **Configure Application Settings**:
   The deployment script automatically sets up:
   - Resource group and storage account
   - Function App with Python runtime
   - Application Insights for monitoring
   - Required environment variables

3. **Verify Deployment**:
   ```bash
   # Check function status
   curl https://your-function-app.azurewebsites.net/api/health
   
   # View logs
   az functionapp logs tail --name your-function-app --resource-group noobie-ai-rg
   ```

## ‚öôÔ∏è Configuration

### Environment Variables

| Variable | Required | Description |
|----------|----------|-------------|
| `NEWS_API_KEY` | Yes | GNews.io API key for news fetching |
| `CLAUDE_API_KEY` | Yes* | Anthropic Claude API key |
| `OPENAI_API_KEY` | Yes* | OpenAI API key (if Claude not available) |
| `GITHUB_TOKEN` | Yes | GitHub PAT with repo access |
| `GITHUB_REPO` | Yes | Target repository (username/repo) |
| `GITHUB_BRANCH` | No | Target branch (default: main) |
| `BLOG_TITLE` | No | Blog title for Jekyll |
| `AUTHOR_NAME` | No | Author name for posts |
| `MAX_ARTICLES` | No | Max articles to process (default: 8) |
| `LOG_LEVEL` | No | Logging level (default: INFO) |
| `MOCK_MODE` | No | Enable mock content for testing |

*At least one AI API key (Claude or OpenAI) is required

### Configuration File

Create `config.json` for persistent settings:

```json
{
  "blog_title": "NOOBIE AI - Daily News Intelligence",
  "blog_description": "AI-powered daily analysis of global news and trends",
  "author_name": "NOOBIE AI",
  "github_repo": "akhilreddydanda/NOOBIE",
  "max_articles": 8,
  "news_categories": [
    "global politics",
    "technology trends",
    "economic developments",
    "international affairs",
    "breaking news"
  ]
}
```

## üìù Usage

### Scheduled Execution

The system automatically runs daily at 8:00 AM UTC:

1. **Fetches** trending news from configured sources
2. **Analyzes** articles using AI for key themes
3. **Generates** comprehensive blog post (800-1500 words)
4. **Publishes** to GitHub Pages with Jekyll optimization
5. **Logs** execution statistics and performance metrics

### Manual Execution

Trigger blog generation manually via HTTP API:

```bash
# Basic manual generation
curl -X POST https://your-function-app.azurewebsites.net/api/manual_generate \
  -H "Content-Type: application/json" \
  -d '{}'

# With custom parameters
curl -X POST https://your-function-app.azurewebsites.net/api/manual_generate \
  -H "Content-Type: application/json" \
  -d '{
    "mock_mode": false,
    "max_articles": 10
  }'
```

### Monitoring and Health Checks

```bash
# Health check (anonymous access)
curl https://your-function-app.azurewebsites.net/api/health

# Detailed status (requires function key)
curl https://your-function-app.azurewebsites.net/api/status?code=your_function_key

# View recent posts
curl https://your-function-app.azurewebsites.net/api/status?code=your_function_key | jq '.recent_posts'
```

## üß™ Testing

### Unit Tests

```bash
# Install test dependencies
pip install pytest pytest-asyncio

# Run all tests
pytest tests/

# Run with coverage
pytest tests/ --cov=claud_agent --cov-report=html
```

### Integration Tests

```bash
# Test news fetching
python -m claud_agent.news_fetcher

# Test blog generation
python -m claud_agent.blog_writer

# Test GitHub publishing (requires valid tokens)
python -m claud_agent.github_publisher
```

### Mock Mode Testing

```bash
# Enable mock mode for testing without API calls
export MOCK_MODE=true
python -c "
from claud_agent.config import load_config
from claud_agent.news_fetcher import NewsFetcher
config = load_config()
config.mock_mode = True
fetcher = NewsFetcher(config)
articles = fetcher.generate_mock_articles('technology', 3)
print(f'Generated {len(articles)} mock articles')
"
```

## üìä Monitoring and Observability

### Logging

- **Console Output**: Colored, emoji-enhanced logs for development
- **File Logging**: Structured JSON logs with rotation
- **Azure Application Insights**: Production telemetry and monitoring

### Key Metrics

- Articles fetched per execution
- Blog generation success rate
- Publishing success rate  
- Average execution time
- API response times
- Error rates by component

### Alerting

Configure Azure Monitor alerts for:
- Function execution failures
- API quota exhaustion
- GitHub publishing failures
- High error rates

## üîß Advanced Configuration

### Custom News Sources

Add RSS feeds to expand news coverage:

```python
# In news_fetcher.py, add custom RSS sources
custom_feeds = [
    ('https://rss.cnn.com/rss/edition.rss', 'international'),
    ('https://feeds.bbci.co.uk/news/world/rss.xml', 'global'),
    ('https://rss.nytimes.com/services/xml/rss/nyt/Technology.xml', 'technology')
]

for feed_url, category in custom_feeds:
    articles.extend(self.fetch_rss_feed(feed_url, category))
```

### AI Model Customization

Customize content generation prompts:

```python
# Modify system prompt in blog_writer.py
custom_prompt = """
You are NOOBIE AI, specializing in [YOUR DOMAIN].
Your analysis should focus on [SPECIFIC ASPECTS].
Write in [YOUR PREFERRED STYLE].
"""
```

### GitHub Pages Themes

Customize Jekyll configuration:

```yaml
# In github_publisher.py, modify Jekyll config
theme: minimal-mistakes
plugins:
  - jekyll-sitemap
  - jekyll-feed
  - jekyll-seo-tag
  - jekyll-paginate-v2
```

## üõ†Ô∏è Development

### Code Structure

- **Modular Design**: Separate concerns for news, AI, and publishing
- **Type Safety**: Full type hints with mypy compatibility
- **Error Handling**: Comprehensive exception handling with recovery
- **Logging**: Structured logging with contextual information
- **Testing**: Unit and integration tests with mocking
- **Documentation**: Inline docstrings and external documentation

### Contributing

1. Fork the repository
2. Create feature branch: `git checkout -b feature/amazing-feature`
3. Commit changes: `git commit -m 'Add amazing feature'`
4. Push to branch: `git push origin feature/amazing-feature`
5. Open Pull Request

### Code Quality

```bash
# Format code
black claud_agent/ azure_function/ tests/

# Lint code
flake8 claud_agent/ azure_function/ tests/

# Type checking
mypy claud_agent/

# Security scanning
bandit -r claud_agent/
```

## üìã Troubleshooting

### Common Issues

**1. API Key Issues**
```bash
# Verify environment variables
env | grep -E "(NEWS_API|CLAUDE_API|OPENAI_API|GITHUB_TOKEN)"

# Test API connectivity
curl -H "Authorization: Bearer $CLAUDE_API_KEY" https://api.anthropic.com/v1/messages
```

**2. GitHub Publishing Failures**
```bash
# Check repository permissions
curl -H "Authorization: token $GITHUB_TOKEN" https://api.github.com/repos/$GITHUB_REPO

# Verify GitHub Pages is enabled
curl -H "Authorization: token $GITHUB_TOKEN" https://api.github.com/repos/$GITHUB_REPO/pages
```

**3. Azure Function Issues**
```bash
# View function logs
az functionapp logs tail --name your-function-app --resource-group noobie-ai-rg

# Check application settings
az functionapp config appsettings list --name your-function-app --resource-group noobie-ai-rg
```

**4. News Fetching Problems**
```bash
# Test GNews API
curl "https://gnews.io/api/v4/search?q=technology&token=$NEWS_API_KEY"

# Test Google News RSS fallback
curl "https://news.google.com/rss/search?q=technology&hl=en-US&gl=US&ceid=US:en"
```

### Debug Mode

Enable detailed debugging:
```bash
export LOG_LEVEL=DEBUG
export MOCK_MODE=true  # For testing without API calls
```

## üìö Resources

- **GNews API Documentation**: [gnews.io/docs](https://gnews.io/docs)
- **Claude API Reference**: [docs.anthropic.com](https://docs.anthropic.com)
- **OpenAI API Guide**: [platform.openai.com/docs](https://platform.openai.com/docs)
- **Azure Functions Python**: [docs.microsoft.com](https://docs.microsoft.com/en-us/azure/azure-functions/functions-reference-python)
- **GitHub Pages Jekyll**: [jekyllrb.com](https://jekyllrb.com)

## ü§ù Support

- **Issues**: [GitHub Issues](https://github.com/akhilreddydanda/NOOBIE/issues)
- **Discussions**: [GitHub Discussions](https://github.com/akhilreddydanda/NOOBIE/discussions)
- **Email**: [akhil@hhamedicine.com](mailto:akhil@hhamedicine.com)

## üìÑ License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## üéØ Roadmap

- [ ] **Multi-language Support**: Support for non-English content generation
- [ ] **Advanced Analytics**: Detailed performance metrics and usage statistics  
- [ ] **Content Scheduling**: Advanced scheduling with timezone support
- [ ] **Social Media Integration**: Auto-posting to Twitter, LinkedIn
- [ ] **Email Newsletters**: Automated newsletter generation and distribution
- [ ] **Custom AI Models**: Fine-tuned models for domain-specific content
- [ ] **WordPress Integration**: Direct publishing to WordPress sites
- [ ] **SEO Optimization**: Advanced SEO analysis and optimization
- [ ] **Content Templates**: Customizable templates for different content types
- [ ] **Multi-tenant Support**: Support for multiple blogs from single deployment

---

**Built with ‚ù§Ô∏è by the NOOBIE AI Team**

*Powered by Azure Functions ‚Ä¢ Enhanced by AI ‚Ä¢ Published to GitHub Pages*

=== FILE: NOOBIE_DEPLOYMENT_COMPLETE.md ===
# NOOBIE AI Deployment Completion Checklist

## üéØ Pre-Deployment Verification

### ‚úÖ System Requirements
- [ ] **Python 3.9+** installed and accessible
- [ ] **Azure CLI** installed and logged in (`az login`)
- [ ] **Azure Functions Core Tools** installed (`npm install -g azure-functions-core-tools@4 --unsafe-perm true`)
- [ ] **Git** installed and configured
- [ ] **GitHub account** with repository access
- [ ] **Active Azure subscription** with sufficient credits

### ‚úÖ API Keys and Credentials
- [ ] **GNews API Key** obtained from [gnews.io](https://gnews.io)
- [ ] **Claude API Key** obtained from [console.anthropic.com](https://console.anthropic.com)
- [ ] **OpenAI API Key** obtained from [platform.openai.com](https://platform.openai.com) (optional)
- [ ] **GitHub Personal Access Token** created with `repo` and `pages` permissions
- [ ] All API keys tested and verified working

### ‚úÖ GitHub Repository Setup
- [ ] Repository created: `akhilreddydanda/NOOBIE`
- [ ] GitHub Pages enabled in repository settings
- [ ] Repository visibility set appropriately (public/private)
- [ ] Branch protection rules configured if needed

---

## üöÄ Deployment Steps

### Step 1: Environment Preparation
```bash
# Navigate to deployment directory
cd /home/akhilreddydanda/NOOBIE-AI/claud-agent

# Verify all files are present
ls -la
# Expected files:
# - deploy_azure.sh
# - claud_agent/
# - azure_function/
# - README_NOOBIE.md
# - NOOBIE_DEPLOYMENT_COMPLETE.md
```
- [ ] All core files verified present
- [ ] Directory structure matches expected layout

### Step 2: Configuration Setup
```bash
# Copy and configure local settings
cp azure_function/local.settings.json azure_function/local.settings.json.backup

# Edit configuration file with your API keys
nano azure_function/local.settings.json
```
**Required Configuration Updates:**
- [ ] `NEWS_API_KEY`: Your GNews API key
- [ ] `CLAUDE_API_KEY`: Your Claude API key  
- [ ] `GITHUB_TOKEN`: Your GitHub personal access token
- [ ] `GITHUB_REPO`: Set to `akhilreddydanda/NOOBIE`
- [ ] `BLOG_TITLE`: Customize if desired
- [ ] `AUTHOR_NAME`: Set to your preferred author name

### Step 3: Azure Resource Deployment
```bash
# Make deployment script executable
chmod +x deploy_azure.sh

# Run deployment script
./deploy_azure.sh
```
**Deployment Checklist:**
- [ ] Resource group `noobie-ai-rg` created successfully
- [ ] Storage account created with unique name
- [ ] Function App created with Python 3.9 runtime
- [ ] Application Insights configured for monitoring
- [ ] Environment variables deployed to Function App
- [ ] Function code deployed successfully

### Step 4: Function Verification
```bash
# Get function app URL (from deployment output)
export FUNCTION_URL="https://noobieAI[timestamp].azurewebsites.net"

# Test health endpoint
curl $FUNCTION_URL/api/health

# Expected response: {"status": "healthy", ...}
```
- [ ] Health endpoint responds with status "healthy"
- [ ] Configuration shows all required API keys present
- [ ] No validation errors in health response

### Step 5: Manual Test Execution
```bash
# Trigger manual blog generation
curl -X POST $FUNCTION_URL/api/manual_generate \
  -H "Content-Type: application/json" \
  -d '{"mock_mode": false}'

# Check execution logs
az functionapp logs tail --name noobieAI[timestamp] --resource-group noobie-ai-rg
```
- [ ] Manual generation completes successfully
- [ ] Blog post created and published to GitHub
- [ ] No critical errors in execution logs
- [ ] GitHub repository shows new blog post

---

## üîç Post-Deployment Verification

### ‚úÖ Function App Status
```bash
# Check function app status
az functionapp show --name noobieAI[timestamp] --resource-group noobie-ai-rg --query "state"

# Verify function configuration
az functionapp config appsettings list --name noobieAI[timestamp] --resource-group noobie-ai-rg
```
- [ ] Function App state is "Running"
- [ ] All environment variables configured correctly
- [ ] No configuration warnings or errors

### ‚úÖ GitHub Pages Verification
```bash
# Check GitHub Pages status
curl -I https://akhilreddydanda.github.io/NOOBIE/

# Expected: HTTP 200 OK response
```
- [ ] GitHub Pages site accessible
- [ ] Blog posts displaying correctly
- [ ] Jekyll theme rendering properly
- [ ] Navigation and layout working

### ‚úÖ Scheduled Timer Function
```bash
# Check timer function configuration
az functionapp function show --function-name daily_blog_generation --name noobieAI[timestamp] --resource-group noobie-ai-rg
```
- [ ] Timer function exists and is enabled
- [ ] Schedule set to "0 0 8 * * *" (8:00 AM UTC daily)
- [ ] Function bindings configured correctly

### ‚úÖ Monitoring and Alerting
```bash
# Check Application Insights connection
az monitor app-insights component show --app noobieAI[timestamp] --resource-group noobie-ai-rg
```
- [ ] Application Insights connected
- [ ] Telemetry data flowing correctly
- [ ] Custom metrics being recorded
- [ ] Error tracking functional

---

## üîß Configuration Validation

### ‚úÖ API Connectivity Tests
```bash
# Test each API endpoint
python3 -c "
import requests
import os

# Test GNews API
gnews_response = requests.get(f'https://gnews.io/api/v4/search?q=test&token={os.getenv(\"NEWS_API_KEY\")}')
print(f'GNews API: {gnews_response.status_code}')

# Test GitHub API  
github_response = requests.get('https://api.github.com/user', headers={'Authorization': f'token {os.getenv(\"GITHUB_TOKEN\")}'})
print(f'GitHub API: {github_response.status_code}')
"
```
- [ ] GNews API returns 200 status
- [ ] GitHub API returns 200 status  
- [ ] Claude API key validated (if used)
- [ ] OpenAI API key validated (if used)

### ‚úÖ Permission Verification
```bash
# Test GitHub repository permissions
curl -H "Authorization: token $GITHUB_TOKEN" \
  https://api.github.com/repos/akhilreddydanda/NOOBIE

# Expected: Repository details with write permissions
```
- [ ] Repository read access confirmed
- [ ] Repository write access confirmed
- [ ] GitHub Pages deployment permissions verified

---

## üéâ Final Validation

### ‚úÖ End-to-End Test
- [ ] **News Fetching**: System retrieves articles from configured sources
- [ ] **AI Generation**: Blog content generated using AI APIs
- [ ] **GitHub Publishing**: Content published to GitHub Pages successfully
- [ ] **Jekyll Processing**: Site builds and deploys correctly
- [ ] **URL Accessibility**: Blog accessible at expected GitHub Pages URL

### ‚úÖ Production Readiness
- [ ] **Logging**: Structured logs flowing to Application Insights
- [ ] **Error Handling**: Graceful degradation when APIs fail
- [ ] **Retry Logic**: Failed operations retry with exponential backoff
- [ ] **Rate Limiting**: API calls respect rate limits
- [ ] **Monitoring**: Health checks and status endpoints working

### ‚úÖ Operational Readiness
- [ ] **Daily Schedule**: Timer function scheduled for 8:00 AM UTC
- [ ] **Manual Triggers**: HTTP endpoints accessible for manual operations
- [ ] **Monitoring Alerts**: Azure Monitor alerts configured (optional)
- [ ] **Backup Strategy**: Local backups enabled if desired

---

## üìä Success Metrics

After 24-48 hours of operation, verify:

- [ ] **Daily Execution**: Timer function executes successfully each day
- [ ] **Content Quality**: Generated blog posts are coherent and relevant
- [ ] **Publishing Success**: ‚â•95% success rate for GitHub publishing
- [ ] **Site Performance**: GitHub Pages site loads in <3 seconds
- [ ] **Error Rate**: <5% error rate in function executions

---

## üÜò Troubleshooting Quick Reference

### Common Issues and Solutions

**üî¥ Function App Won't Start**
```bash
# Check function app logs
az functionapp logs tail --name noobieAI[timestamp] --resource-group noobie-ai-rg

# Common fixes:
# 1. Verify Python runtime version (3.9)
# 2. Check requirements.txt dependencies
# 3. Validate environment variables
```

**üî¥ API Authentication Failures**
```bash
# Test API keys individually
curl -H "Authorization: Bearer $CLAUDE_API_KEY" https://api.anthropic.com/v1/messages
curl -H "Authorization: token $GITHUB_TOKEN" https://api.github.com/user
```

**üî¥ GitHub Publishing Fails**
```bash
# Check repository permissions
curl -H "Authorization: token $GITHUB_TOKEN" https://api.github.com/repos/akhilreddydanda/NOOBIE

# Verify GitHub Pages settings
# Go to: https://github.com/akhilreddydanda/NOOBIE/settings/pages
```

**üî¥ Timer Function Not Triggering**
```bash
# Check timer configuration
az functionapp function show --function-name daily_blog_generation --name noobieAI[timestamp] --resource-group noobie-ai-rg

# Manually trigger for testing
curl -X POST "$FUNCTION_URL/api/manual_generate"
```

---

## üéØ Next Steps

### Immediate Actions (First Week)
- [ ] **Monitor Daily Executions**: Check logs daily for first week
- [ ] **Review Generated Content**: Ensure content quality meets expectations
- [ ] **Optimize Configuration**: Adjust max_articles, categories as needed
- [ ] **Set Up Alerts**: Configure Azure Monitor alerts for failures

### Long-term Optimizations (First Month)
- [ ] **Performance Tuning**: Optimize API usage and execution time
- [ ] **Content Enhancement**: Refine AI prompts for better output
- [ ] **Additional Sources**: Add more news sources if needed
- [ ] **Analytics Integration**: Add Google Analytics to GitHub Pages site

### Advanced Features (Future)
- [ ] **Social Media Integration**: Auto-post to Twitter/LinkedIn
- [ ] **Email Notifications**: Set up email alerts for failures
- [ ] **A/B Testing**: Test different content generation approaches
- [ ] **Multi-language Support**: Expand to other languages

---

## ‚úÖ Deployment Complete!

**Congratulations! üéâ** Your NOOBIE AI system is now fully deployed and operational.

### Key Information to Save:
- **Function App URL**: `https://noobieAI[timestamp].azurewebsites.net`
- **GitHub Pages URL**: `https://akhilreddydanda.github.io/NOOBIE/`
- **Resource Group**: `noobie-ai-rg`
- **Daily Schedule**: 8:00 AM UTC

### Quick Access Commands:
```bash
# View logs
az functionapp logs tail --name noobieAI[timestamp] --resource-group noobie-ai-rg

# Manual trigger
curl -X POST "https://noobieAI[timestamp].azurewebsites.net/api/manual_generate"

# Health check
curl "https://noobieAI[timestamp].azurewebsites.net/api/health"
```

---

**üöÄ Your AI-powered blog is now live and automatically generating daily content!**

*For support, issues, or questions, please refer to the README_NOOBIE.md documentation or create an issue in the GitHub repository.*

=== FILE: deploy_azure.sh ===
#!/bin/bash

# ================================================================================
# NOOBIE AI - AZURE FUNCTIONS DEPLOYMENT SCRIPT
# ================================================================================
# Professional-grade deployment script for NOOBIE AI blog generation system
# Author: Akhil Reddy
# GitHub: akhilreddydanda/NOOBIE
# ================================================================================

set -e  # Exit immediately if a command exits with a non-zero status

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Configuration
RESOURCE_GROUP="noobie-ai-rg"
LOCATION="East US"
STORAGE_ACCOUNT="noobieaistorage$(date +%s)"
FUNCTION_APP="noobieAI$(date +%s)"
PYTHON_VERSION="3.11"
GITHUB_REPO="akhilreddydanda/NOOBIE"

# Logging function
log() {
    echo -e "${CYAN}[$(date +'%Y-%m-%d %H:%M:%S')]${NC} $1"
}

error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

# Banner
echo -e "${PURPLE}"
cat << "EOF"
 _   _  ___   ___  ____  _____ _____      _    _____ 
| \ | |/ _ \ / _ \| __ )|_ _| | ____|    / \  |_ _|
|  \| | | | | | | |  _ \ | |  |  _|     / _ \  | | 
| |\  | |_| | |_| | |_) || |  | |___   / ___ \ | | 
|_| \_|\___/ \___/|____/|___| |_____| /_/   \_\___|
                                                   
    Azure Functions Deployment System
    Enterprise-Grade AI Blog Automation
EOF
echo -e "${NC}"

log "üöÄ Starting NOOBIE AI deployment to Azure Functions..."
log "üìã Configuration:"
log "   ‚Ä¢ Resource Group: ${RESOURCE_GROUP}"
log "   ‚Ä¢ Location: ${LOCATION}"
log "   ‚Ä¢ Storage Account: ${STORAGE_ACCOUNT}"
log "   ‚Ä¢ Function App: ${FUNCTION_APP}"
log "   ‚Ä¢ Python Version: ${PYTHON_VERSION}"
log "   ‚Ä¢ GitHub Repository: ${GITHUB_REPO}"
echo ""

# Prerequisites check
log "üîç Checking prerequisites..."

# Check Azure CLI
if ! command -v az &> /dev/null; then
    error "Azure CLI is not installed. Installing now..."
    curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash
    success "Azure CLI installed successfully"
else
    success "Azure CLI found: $(az version --query '"azure-cli"' -o tsv)"
fi

# Check Azure Functions Core Tools
if ! command -v func &> /dev/null; then
    error "Azure Functions Core Tools not found. Installing now..."
    npm install -g azure-functions-core-tools@4 --unsafe-perm true
    success "Azure Functions Core Tools installed successfully"
else
    success "Azure Functions Core Tools found: $(func --version)"
fi

# Check Azure login
log "üîê Checking Azure authentication..."
if ! az account show &> /dev/null; then
    error "Not logged in to Azure. Please run: az login"
    exit 1
else
    ACCOUNT_NAME=$(az account show --query user.name -o tsv)
    SUBSCRIPTION_ID=$(az account show --query id -o tsv)
    success "Logged in as: ${ACCOUNT_NAME}"
    log "   ‚Ä¢ Subscription: ${SUBSCRIPTION_ID}"
fi

# Check for configuration file
if [[ ! -f "azure_settings.json" ]]; then
    warning "azure_settings.json not found. Creating template..."
    cat > azure_settings.json << 'EOL'
[
  {
    "name": "NEWS_API_KEY",
    "value": "your-gnews-api-key-here",
    "slotSetting": false
  },
  {
    "name": "CLAUDE_API_KEY",
    "value": "your-claude-api-key-here",
    "slotSetting": false
  },
  {
    "name": "GITHUB_TOKEN",
    "value": "your-github-token-here",
    "slotSetting": false
  },
  {
    "name": "GITHUB_REPO",
    "value": "akhilreddydanda/NOOBIE",
    "slotSetting": false
  },
  {
    "name": "UPLOAD_TO_GITHUB",
    "value": "true",
    "slotSetting": false
  },
  {
    "name": "MAX_ARTICLES",
    "value": "8",
    "slotSetting": false
  },
  {
    "name": "LOG_LEVEL",
    "value": "INFO",
    "slotSetting": false
  }
]
EOL
    warning "Please edit azure_settings.json with your actual API keys before continuing!"
    read -p "Have you updated azure_settings.json with your API keys? (y/N): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        error "Please update azure_settings.json with your API keys and run this script again."
        exit 1
    fi
fi

echo ""
log "üèóÔ∏è  Creating Azure resources..."

# Create resource group
log "üìÅ Creating resource group: ${RESOURCE_GROUP}"
az group create \
    --name "${RESOURCE_GROUP}" \
    --location "${LOCATION}" \
    --output table

success "Resource group created successfully"

# Create storage account
log "üíæ Creating storage account: ${STORAGE_ACCOUNT}"
az storage account create \
    --name "${STORAGE_ACCOUNT}" \
    --location "${LOCATION}" \
    --resource-group "${RESOURCE_GROUP}" \
    --sku Standard_LRS \
    --output table

success "Storage account created successfully"

# Create function app
log "‚ö° Creating function app: ${FUNCTION_APP}"
az functionapp create \
    --resource-group "${RESOURCE_GROUP}" \
    --consumption-plan-location "${LOCATION}" \
    --runtime python \
    --runtime-version "${PYTHON_VERSION}" \
    --functions-version 4 \
    --name "${FUNCTION_APP}" \
    --storage-account "${STORAGE_ACCOUNT}" \
    --os-type Linux \
    --output table

success "Function app created successfully"

# Configure application settings
log "‚öôÔ∏è  Configuring application settings..."
az functionapp config appsettings set \
    --name "${FUNCTION_APP}" \
    --resource-group "${RESOURCE_GROUP}" \
    --settings @azure_settings.json \
    --output table

success "Application settings configured"

# Create local.settings.json for local development
log "üìÅ Creating local development settings..."
cat > local.settings.json << EOL
{
  "IsEncrypted": false,
  "Values": {
    "AzureWebJobsStorage": "",
    "FUNCTIONS_WORKER_RUNTIME": "python",
    "NEWS_API_KEY": "your-gnews-api-key-here",
    "CLAUDE_API_KEY": "your-claude-api-key-here",
    "GITHUB_TOKEN": "your-github-token-here",
    "GITHUB_REPO": "${GITHUB_REPO}",
    "UPLOAD_TO_GITHUB": "true",
    "MAX_ARTICLES": "8",
    "LOG_LEVEL": "INFO"
  }
}
EOL

# Deploy the function
log "üöÄ Deploying NOOBIE AI to Azure Functions..."
log "   ‚Ä¢ Packaging application..."
log "   ‚Ä¢ Uploading to Azure..."

if func azure functionapp publish "${FUNCTION_APP}" --python; then
    success "Function deployed successfully!"
else
    error "Function deployment failed!"
    exit 1
fi

# Enable Application Insights
log "üìä Setting up Application Insights for monitoring..."
INSTRUMENTATION_KEY=$(az monitor app-insights component create \
    --app "${FUNCTION_APP}" \
    --location "${LOCATION}" \
    --resource-group "${RESOURCE_GROUP}" \
    --query 'instrumentationKey' \
    --output tsv)

az functionapp config appsettings set \
    --name "${FUNCTION_APP}" \
    --resource-group "${RESOURCE_GROUP}" \
    --settings "APPINSIGHTS_INSTRUMENTATIONKEY=${INSTRUMENTATION_KEY}" \
    --output table

success "Application Insights configured"

# Verify deployment
log "üîç Verifying deployment..."
FUNCTION_STATE=$(az functionapp show \
    --name "${FUNCTION_APP}" \
    --resource-group "${RESOURCE_GROUP}" \
    --query "state" \
    --output tsv)

if [[ "${FUNCTION_STATE}" == "Running" ]]; then
    success "Function app is running successfully!"
else
    warning "Function app state: ${FUNCTION_STATE}"
fi

# Display deployment summary
echo ""
echo -e "${GREEN}üéâ NOOBIE AI DEPLOYMENT COMPLETED SUCCESSFULLY!${NC}"
echo "==============================================="
echo ""
echo -e "${CYAN}üìã Deployment Summary:${NC}"
echo "   ‚Ä¢ Function App Name: ${FUNCTION_APP}"
echo "   ‚Ä¢ Function URL: https://${FUNCTION_APP}.azurewebsites.net"
echo "   ‚Ä¢ Resource Group: ${RESOURCE_GROUP}"
echo "   ‚Ä¢ Region: ${LOCATION}"
echo "   ‚Ä¢ Runtime: Python ${PYTHON_VERSION}"
echo "   ‚Ä¢ Schedule: Daily at 8:00 AM UTC"
echo ""
echo -e "${CYAN}üîó Important URLs:${NC}"
echo "   ‚Ä¢ Azure Portal: https://portal.azure.com"
echo "   ‚Ä¢ Function Management: https://portal.azure.com/#@/resource/subscriptions/$(az account show --query id -o tsv)/resourceGroups/${RESOURCE_GROUP}/providers/Microsoft.Web/sites/${FUNCTION_APP}"
echo "   ‚Ä¢ GitHub Repository: https://github.com/${GITHUB_REPO}"
echo ""
echo -e "${CYAN}üìä Monitoring Commands:${NC}"
echo "   ‚Ä¢ View logs: az functionapp logs tail --name ${FUNCTION_APP} --resource-group ${RESOURCE_GROUP}"
echo "   ‚Ä¢ Function status: az functionapp show --name ${FUNCTION_APP} --resource-group ${RESOURCE_GROUP}"
echo "   ‚Ä¢ Restart function: az functionapp restart --name ${FUNCTION_APP} --resource-group ${RESOURCE_GROUP}"
echo ""
echo -e "${CYAN}üîß Management Commands:${NC}"
echo "   ‚Ä¢ Update settings: az functionapp config appsettings set --name ${FUNCTION_APP} --resource-group ${RESOURCE_GROUP} --settings 'KEY=value'"
echo "   ‚Ä¢ Delete resources: az group delete --name ${RESOURCE_GROUP} --yes --no-wait"
echo ""
echo -e "${YELLOW}üí° What happens next:${NC}"
echo "   1. üïí NOOBIE AI will run automatically at 8:00 AM UTC daily"
echo "   2. üì∞ Fetch trending news from multiple sources"
echo "   3. ü§ñ Generate AI blog posts using Claude"
echo "   4. üì§ Upload to GitHub repository: ${GITHUB_REPO}"
echo "   5. üìä Log detailed execution statistics"
echo ""
echo -e "${GREEN}üöÄ Your NOOBIE AI system is now live and running 24/7!${NC}"
echo ""

# Save deployment info
cat > deployment_info.json << EOL
{
  "deployment_date": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "function_app_name": "${FUNCTION_APP}",
  "resource_group": "${RESOURCE_GROUP}",
  "location": "${LOCATION}",
  "function_url": "https://${FUNCTION_APP}.azurewebsites.net",
  "github_repo": "${GITHUB_REPO}",
  "schedule": "Daily at 8:00 AM UTC",
  "status": "deployed"
}
EOL

success "Deployment information saved to deployment_info.json"
log "üéØ NOOBIE AI deployment completed successfully!"

=== FILE: claud_agent/__init__.py ===
"""
NOOBIE AI - Intelligent Blog Generation System
==============================================

A production-grade AI system that automatically generates daily blog posts
from trending world news using advanced language models.

Features:
- Multi-source news aggregation
- Claude AI-powered content generation
- Automated GitHub Pages publishing
- Azure Functions cloud deployment
- Comprehensive error handling and logging

Author: Akhil Reddy
Repository: https://github.com/akhilreddydanda/NOOBIE
"""

__version__ = "1.0.0"
__author__ = "Akhil Reddy"
__email__ = "akhil@hhamedicine.com"
__description__ = "NOOBIE AI - Intelligent automated blog generation system"
__url__ = "https://github.com/akhilreddydanda/NOOBIE"

# Core imports
from .news_fetcher import NewsFetcher, NewsArticle
from .blog_writer import BlogWriter, BlogPost
from .github_publisher import GitHubPublisher, PublishResult
from .orchestrator import NoobieOrchestrator
from .config import NoobieConfig
from .logger import get_logger, setup_logging

# Export main classes
__all__ = [
    'NewsFetcher',
    'NewsArticle',
    'BlogWriter', 
    'BlogPost',
    'GitHubPublisher',
    'PublishResult',
    'NoobieOrchestrator',
    'NoobieConfig',
    'get_logger',
    'setup_logging'
]

# Package metadata
PACKAGE_INFO = {
    'name': 'noobie-ai',
    'version': __version__,
    'author': __author__,
    'description': __description__,
    'url': __url__,
    'license': 'MIT',
    'python_requires': '>=3.8',
    'keywords': ['ai', 'blog', 'automation', 'news', 'claude', 'azure'],
    'classifiers': [
        'Development Status :: 5 - Production/Stable',
        'Intended Audience :: Developers',
        'License :: OSI Approved :: MIT License',
        'Programming Language :: Python :: 3.8',
        'Programming Language :: Python :: 3.9',
        'Programming Language :: Python :: 3.10',
        'Programming Language :: Python :: 3.11',
        'Topic :: Software Development :: Libraries :: Python Modules',
        'Topic :: Internet :: WWW/HTTP :: Dynamic Content :: News/Diary',
    ]
}

=== FILE: claud_agent/config.py ===
"""
NOOBIE AI Configuration Management
=================================

Handles all configuration loading, validation, and environment management
for the NOOBIE AI system.
"""

import os
import json
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any
from pathlib import Path

@dataclass
class NoobieConfig:
    """
    Configuration class for NOOBIE AI system
    """
    # API Keys
    news_api_key: Optional[str] = None
    claude_api_key: Optional[str] = None
    openai_api_key: Optional[str] = None
    
    # GitHub Configuration
    github_token: Optional[str] = None
    github_repo: str = "akhilreddydanda/NOOBIE"
    github_branch: str = "main"
    
    # Blog Configuration
    blog_title: str = "NOOBIE AI - Daily News Intelligence"
    blog_description: str = "AI-powered daily analysis of global news and trends"
    author_name: str = "NOOBIE AI"
    
    # Processing Settings
    max_articles: int = 8
    min_article_length: int = 100
    max_blog_length: int = 3000
    
    # Logging
    log_level: str = "INFO"
    enable_console_logging: bool = True
    enable_file_logging: bool = True
    
    # Azure Settings
    function_timeout: int = 600  # 10 minutes
    retry_attempts: int = 3
    retry_delay: int = 5
    
    # Feature Flags
    upload_to_github: bool = True
    save_local_backup: bool = True
    enable_analytics: bool = True
    mock_mode: bool = False
    
    # News Categories
    news_categories: List[str] = field(default_factory=lambda: [
        "global politics",
        "technology trends", 
        "economic developments",
        "international affairs",
        "breaking news"
    ])
    
    @classmethod
    def from_env(cls) -> 'NoobieConfig':
        """Create configuration from environment variables"""
        return cls(
            # API Keys
            news_api_key=os.getenv('NEWS_API_KEY'),
            claude_api_key=os.getenv('CLAUDE_API_KEY'),
            openai_api_key=os.getenv('OPENAI_API_KEY'),
            
            # GitHub
            github_token=os.getenv('GITHUB_TOKEN'),
            github_repo=os.getenv('GITHUB_REPO', 'akhilreddydanda/NOOBIE'),
            github_branch=os.getenv('GITHUB_BRANCH', 'main'),
            
            # Blog Settings
            blog_title=os.getenv('BLOG_TITLE', 'NOOBIE AI - Daily News Intelligence'),
            author_name=os.getenv('AUTHOR_NAME', 'NOOBIE AI'),
            
            # Processing
            max_articles=int(os.getenv('MAX_ARTICLES', '8')),
            log_level=os.getenv('LOG_LEVEL', 'INFO'),
            
            # Features
            upload_to_github=os.getenv('UPLOAD_TO_GITHUB', 'true').lower() == 'true',
            mock_mode=os.getenv('MOCK_MODE', 'false').lower() == 'true',
            retry_attempts=int(os.getenv('RETRY_ATTEMPTS', '3')),
        )
    
    @classmethod
    def from_file(cls, config_path: str) -> 'NoobieConfig':
        """Load configuration from JSON file"""
        with open(config_path, 'r') as f:
            config_data = json.load(f)
        
        return cls(**config_data)
    
    def validate(self) -> List[str]:
        """Validate configuration and return list of errors"""
        errors = []
        
        # Check required API keys
        if not self.news_api_key:
            errors.append("NEWS_API_KEY is required")
        
        if not self.claude_api_key and not self.openai_api_key:
            errors.append("At least one AI API key (CLAUDE_API_KEY or OPENAI_API_KEY) is required")
        
        if self.upload_to_github and not self.github_token:
            errors.append("GITHUB_TOKEN is required when upload_to_github is enabled")
        
        # Validate ranges
        if self.max_articles < 1 or self.max_articles > 20:
            errors.append("max_articles must be between 1 and 20")
        
        if self.retry_attempts < 1 or self.retry_attempts > 10:
            errors.append("retry_attempts must be between 1 and 10")
        
        return errors
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert config to dictionary (excluding sensitive data)"""
        return {
            'github_repo': self.github_repo,
            'github_branch': self.github_branch,
            'blog_title': self.blog_title,
            'blog_description': self.blog_description,
            'author_name': self.author_name,
            'max_articles': self.max_articles,
            'log_level': self.log_level,
            'upload_to_github': self.upload_to_github,
            'mock_mode': self.mock_mode,
            'news_categories': self.news_categories,
            'has_news_api_key': bool(self.news_api_key),
            'has_claude_api_key': bool(self.claude_api_key),
            'has_github_token': bool(self.github_token),
        }
    
    def save_to_file(self, config_path: str) -> None:
        """Save configuration to JSON file (excluding sensitive data)"""
        config_dict = self.to_dict()
        
        with open(config_path, 'w') as f:
            json.dump(config_dict, f, indent=2)

def load_config() -> NoobieConfig:
    """
    Load configuration with priority:
    1. Environment variables
    2. config.json file
    3. Default values
    """
    # Try to load from environment first
    config = NoobieConfig.from_env()
    
    # Check for config file
    config_file = Path('config.json')
    if config_file.exists():
        try:
            file_config = NoobieConfig.from_file(str(config_file))
            # Merge configurations (env takes priority)
            for field_name, field_def in config.__dataclass_fields__.items():
                env_value = getattr(config, field_name)
                file_value = getattr(file_config, field_name)
                
                # Use env value if set, otherwise use file value
                if env_value == field_def.default:
                    setattr(config, field_name, file_value)
                    
        except Exception as e:
            print(f"Warning: Could not load config.json: {e}")
    
    return config

def create_sample_config() -> None:
    """Create a sample configuration file"""
    sample_config = {
        "blog_title": "NOOBIE AI - Daily News Intelligence",
        "blog_description": "AI-powered daily analysis of global news and trends",
        "author_name": "NOOBIE AI",
        "github_repo": "akhilreddydanda/NOOBIE",
        "github_branch": "main",
        "max_articles": 8,
        "log_level": "INFO",
        "upload_to_github": True,
        "mock_mode": False,
        "news_categories": [
            "global politics",
            "technology trends",
            "economic developments", 
            "international affairs",
            "breaking news"
        ]
    }
    
    with open('config.json', 'w') as f:
        json.dump(sample_config, f, indent=2)
    
    print("Sample config.json created. Please edit with your settings.")

=== FILE: claud_agent/logger.py ===
"""
NOOBIE AI Logging System
=======================

Production-grade logging with colored console output, file rotation,
and structured JSON logging for Azure Application Insights.
"""

import logging
import logging.handlers
import sys
import json
from datetime import datetime
from pathlib import Path
from typing import Dict, Any, Optional

class ColoredFormatter(logging.Formatter):
    """Custom formatter with colors and emojis for console output"""
    
    # Color codes
    COLORS = {
        'DEBUG': '\033[36m',    # Cyan
        'INFO': '\033[32m',     # Green
        'WARNING': '\033[33m',  # Yellow
        'ERROR': '\033[31m',    # Red
        'CRITICAL': '\033[35m', # Magenta
        'RESET': '\033[0m'      # Reset
    }
    
    # Emoji indicators
    EMOJIS = {
        'DEBUG': 'üîç',
        'INFO': '‚úÖ',
        'WARNING': '‚ö†Ô∏è',
        'ERROR': '‚ùå',
        'CRITICAL': 'üí•'
    }
    
    def format(self, record):
        # Add color and emoji
        level_name = record.levelname
        color = self.COLORS.get(level_name, self.COLORS['RESET'])
        emoji = self.EMOJIS.get(level_name, 'üìù')
        
        # Format timestamp
        timestamp = datetime.fromtimestamp(record.created).strftime('%Y-%m-%d %H:%M:%S')
        
        # Create formatted message
        message = super().format(record)
        
        return f"[{timestamp}] {emoji} {color}{level_name}{self.COLORS['RESET']} - {record.name}:{record.funcName}:{record.lineno} - {message}"

class JSONFormatter(logging.Formatter):
    """JSON formatter for structured logging"""
    
    def format(self, record):
        log_entry = {
            'timestamp': datetime.fromtimestamp(record.created).isoformat(),
            'level': record.levelname,
            'logger': record.name,
            'function': record.funcName,
            'line': record.lineno,
            'message': record.getMessage(),
            'module': record.module,
            'pathname': record.pathname
        }
        
        # Add exception info if present
        if record.exc_info:
            log_entry['exception'] = self.formatException(record.exc_info)
        
        # Add extra fields if present
        if hasattr(record, 'extra_data'):
            log_entry.update(record.extra_data)
        
        return json.dumps(log_entry, ensure_ascii=False)

class NoobieLogger:
    """NOOBIE AI Logger with advanced features"""
    
    def __init__(self, name: str):
        self.logger = logging.getLogger(name)
        self.logger.setLevel(logging.DEBUG)
        self.name = name
        self._handlers_configured = False
    
    def configure_handlers(self, 
                          log_level: str = "INFO",
                          enable_console: bool = True,
                          enable_file: bool = True,
                          log_file: Optional[str] = None):
        """Configure logging handlers"""
        
        if self._handlers_configured:
            return
        
        # Clear existing handlers
        self.logger.handlers.clear()
        
        # Set log level
        numeric_level = getattr(logging, log_level.upper(), logging.INFO)
        self.logger.setLevel(numeric_level)
        
        # Console handler with colors
        if enable_console:
            console_handler = logging.StreamHandler(sys.stdout)
            console_handler.setLevel(numeric_level)
            console_formatter = ColoredFormatter()
            console_handler.setFormatter(console_formatter)
            self.logger.addHandler(console_handler)
        
        # File handler with JSON formatting
        if enable_file:
            # Create logs directory
            log_dir = Path("logs")
            log_dir.mkdir(exist_ok=True)
            
            # Use provided log file or default
            if not log_file:
                log_file = log_dir / f"noobie_{datetime.now().strftime('%Y-%m-%d')}.log"
            
            # Rotating file handler
            file_handler = logging.handlers.RotatingFileHandler(
                log_file,
                maxBytes=10 * 1024 * 1024,  # 10MB
                backupCount=5,
                encoding='utf-8'
            )
            file_handler.setLevel(logging.DEBUG)  # Always DEBUG for files
            file_formatter = JSONFormatter()
            file_handler.setFormatter(file_formatter)
            self.logger.addHandler(file_handler)
        
        self._handlers_configured = True
    
    def debug(self, message: str, extra_data: Optional[Dict[str, Any]] = None):
        """Log debug message"""
        if extra_data:
            self.logger.debug(message, extra={'extra_data': extra_data})
        else:
            self.logger.debug(message)
    
    def info(self, message: str, extra_data: Optional[Dict[str, Any]] = None):
        """Log info message"""
        if extra_data:
            self.logger.info(message, extra={'extra_data': extra_data})
        else:
            self.logger.info(message)
    
    def warning(self, message: str, extra_data: Optional[Dict[str, Any]] = None):
        """Log warning message"""
        if extra_data:
            self.logger.warning(message, extra={'extra_data': extra_data})
        else:
            self.logger.warning(message)
    
    def error(self, message: str, extra_data: Optional[Dict[str, Any]] = None):
        """Log error message"""
        if extra_data:
            self.logger.error(message, extra={'extra_data': extra_data})
        else:
            self.logger.error(message)
    
    def critical(self, message: str, extra_data: Optional[Dict[str, Any]] = None):
        """Log critical message"""
        if extra_data:
            self.logger.critical(message, extra={'extra_data': extra_data})
        else:
            self.logger.critical(message)
    
    def exception(self, message: str, extra_data: Optional[Dict[str, Any]] = None):
        """Log exception with stack trace"""
        if extra_data:
            self.logger.exception(message, extra={'extra_data': extra_data})
        else:
            self.logger.exception(message)

# Global logger registry
_loggers: Dict[str, NoobieLogger] = {}

def get_logger(name: str) -> NoobieLogger:
    """Get or create a logger instance"""
    if name not in _loggers:
        _loggers[name] = NoobieLogger(name)
    return _loggers[name]

def setup_logging(log_level: str = "INFO",
                 enable_console: bool = True,
                 enable_file: bool = True,
                 log_file: Optional[str] = None) -> None:
    """Setup global logging configuration"""
    
    # Configure root logger
    root_logger = get_logger("noobie_ai")
    root_logger.configure_handlers(log_level, enable_console, enable_file, log_file)
    
    # Configure all existing loggers
    for logger in _loggers.values():
        logger.configure_handlers(log_level, enable_console, enable_file, log_file)
    
    root_logger.info(f"üìã Logging configured - Level: {log_level}, Console: {enable_console}, File: {enable_file}")

def log_execution_stats(stats: Dict[str, Any]) -> None:
    """Log execution statistics in structured format"""
    logger = get_logger("noobie_ai.stats")
    logger.info("üìä Execution Statistics", extra_data=stats)

def log_performance_metric(metric_name: str, value: float, unit: str = "") -> None:
    """Log performance metric"""
    logger = get_logger("noobie_ai.performance")
    logger.info(f"üìà {metric_name}: {value}{unit}", extra_data={
        'metric_name': metric_name,
        'value': value,
        'unit': unit,
        'timestamp': datetime.utcnow().isoformat()
    })

# Context manager for operation logging
class LogOperation:
    """Context manager for logging operation start/end with timing"""
    
    def __init__(self, operation_name: str, logger: Optional[NoobieLogger] = None):
        self.operation_name = operation_name
        self.logger = logger or get_logger("noobie_ai.operations")
        self.start_time = None
    
    def __enter__(self):
        self.start_time = datetime.utcnow()
        self.logger.info(f"üöÄ Starting: {self.operation_name}")
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        duration = (datetime.utcnow() - self.start_time).total_seconds()
        
        if exc_type:
            self.logger.error(f"‚ùå Failed: {self.operation_name} ({duration:.2f}s)", extra_data={
                'operation': self.operation_name,
                'duration_seconds': duration,
                'success': False,
                'error_type': exc_type.__name__ if exc_type else None,
                'error_message': str(exc_val) if exc_val else None
            })
        else:
            self.logger.info(f"‚úÖ Completed: {self.operation_name} ({duration:.2f}s)", extra_data={
                'operation': self.operation_name,
                'duration_seconds': duration,
                'success': True
            })

# Export main functions
__all__ = [
    'get_logger',
    'setup_logging',
    'log_execution_stats',
    'log_performance_metric',
    'LogOperation',
    'NoobieLogger'
]

=== FILE: claud_agent/news_fetcher.py ===
"""
NOOBIE AI News Fetcher
=====================

Advanced news aggregation system with multiple sources, fallbacks,
rate limiting, and intelligent content filtering.
"""

import requests
import feedparser
import time
import random
from datetime import datetime, timedelta
from typing import List, Dict, Any, Optional
from dataclasses import dataclass
from urllib.parse import urlencode
import json

from .logger import get_logger, LogOperation
from .config import NoobieConfig

@dataclass
class NewsArticle:
    """Data class for news articles"""
    title: str
    summary: str
    url: str
    published_date: str
    source: str
    category: str
    content: Optional[str] = None
    author: Optional[str] = None
    image_url: Optional[str] = None
    sentiment_score: Optional[float] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert article to dictionary"""
        return {
            'title': self.title,
            'summary': self.summary,
            'url': self.url,
            'published_date': self.published_date,
            'source': self.source,
            'category': self.category,
            'content': self.content,
            'author': self.author,
            'image_url': self.image_url,
            'sentiment_score': self.sentiment_score
        }

class NewsFetcher:
    """
    Advanced news fetcher with multiple sources and intelligent aggregation
    """
    
    def __init__(self, config: NoobieConfig):
        self.config = config
        self.logger = get_logger(__name__)
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'NOOBIE-AI/1.0 (News Aggregator; akhil@hhamedicine.com)'
        })
        
        # Rate limiting
        self.last_request_time = 0
        self.min_request_interval = 1.0  # Minimum 1 second between requests
        
        # API endpoints
        self.gnews_base_url = "https://gnews.io/api/v4/search"
        self.newsapi_base_url = "https://newsapi.org/v2/everything"
    
    def _rate_limit(self) -> None:
        """Implement rate limiting between requests"""
        current_time = time.time()
        time_since_last = current_time - self.last_request_time
        
        if time_since_last < self.min_request_interval:
            sleep_time = self.min_request_interval - time_since_last
            time.sleep(sleep_time)
        
        self.last_request_time = time.time()
    
    def _make_request_with_retry(self, url: str, params: Dict[str, Any], max_retries: int = 3) -> Optional[Dict[str, Any]]:
        """Make HTTP request with retry logic and exponential backoff"""
        
        for attempt in range(max_retries):
            try:
                self._rate_limit()
                
                self.logger.debug(f"üì° Making request to: {url}", extra_data={
                    'url': url,
                    'params': params,
                    'attempt': attempt + 1
                })
                
                response = self.session.get(url, params=params, timeout=30)
                response.raise_for_status()
                
                return response.json()
                
            except requests.exceptions.RequestException as e:
                wait_time = (2 ** attempt) + random.uniform(0, 1)
                self.logger.warning(f"üîÑ Request failed (attempt {attempt + 1}/{max_retries}): {e}")
                
                if attempt < max_retries - 1:
                    self.logger.info(f"‚è≥ Waiting {wait_time:.2f}s before retry...")
                    time.sleep(wait_time)
                else:
                    self.logger.error(f"‚ùå All retry attempts failed for: {url}")
                    
        return None
    
    def fetch_gnews(self, query: str, max_results: int = 10) -> List[NewsArticle]:
        """Fetch news from GNews API"""
        
        if not self.config.news_api_key:
            self.logger.warning("üîë GNews API key not configured")
            return []
        
        with LogOperation(f"GNews fetch: {query}", self.logger):
            params = {
                'q': query,
                'lang': 'en',
                'country': 'us',
                'max': min(max_results, 10),  # GNews limit
                'apikey': self.config.news_api_key
            }
            
            data = self._make_request_with_retry(self.gnews_base_url, params)
            
            if not data or 'articles' not in data:
                self.logger.warning(f"üö´ No articles found for query: {query}")
                return []
            
            articles = []
            for article_data in data['articles'][:max_results]:
                try:
                    article = NewsArticle(
                        title=article_data.get('title', ''),
                        summary=article_data.get('description', ''),
                        url=article_data.get('url', ''),
                        published_date=article_data.get('publishedAt', ''),
                        source=article_data.get('source', {}).get('name', 'Unknown'),
                        category=query,
                        content=article_data.get('content'),
                        author=article_data.get('author'),
                        image_url=article_data.get('image')
                    )
                    
                    if article.title and article.summary:
                        articles.append(article)
                        
                except Exception as e:
                    self.logger.warning(f"‚ö†Ô∏è Error parsing article: {e}")
                    continue
            
            self.logger.info(f"‚úÖ Fetched {len(articles)} articles from GNews for: {query}")
            return articles
    
    def fetch_rss_feed(self, feed_url: str, category: str, max_results: int = 10) -> List[NewsArticle]:
        """Fetch news from RSS feed"""
        
        with LogOperation(f"RSS fetch: {feed_url}", self.logger):
            try:
                self._rate_limit()
                
                # Parse RSS feed
                feed = feedparser.parse(feed_url)
                
                if feed.bozo:
                    self.logger.warning(f"‚ö†Ô∏è RSS feed parsing issues: {feed_url}")
                
                articles = []
                for entry in feed.entries[:max_results]:
                    try:
                        # Parse publication date
                        pub_date = entry.get('published', '')
                        if hasattr(entry, 'published_parsed') and entry.published_parsed:
                            pub_date = datetime(*entry.published_parsed[:6]).isoformat()
                        
                        article = NewsArticle(
                            title=entry.get('title', ''),
                            summary=entry.get('summary', entry.get('description', '')),
                            url=entry.get('link', ''),
                            published_date=pub_date,
                            source=feed.feed.get('title', 'RSS Feed'),
                            category=category,
                            author=entry.get('author')
                        )
                        
                        if article.title and article.summary:
                            articles.append(article)
                            
                    except Exception as e:
                        self.logger.warning(f"‚ö†Ô∏è Error parsing RSS entry: {e}")
                        continue
                
                self.logger.info(f"‚úÖ Fetched {len(articles)} articles from RSS: {category}")
                return articles
                
            except Exception as e:
                self.logger.error(f"‚ùå Error fetching RSS feed {feed_url}: {e}")
                return []
    
    def fetch_google_news_rss(self, query: str, max_results: int = 10) -> List[NewsArticle]:
        """Fetch news from Google News RSS (no API key required)"""
        
        # Encode query for URL
        encoded_query = urlencode({'q': query})
        rss_url = f"https://news.google.com/rss/search?{encoded_query}&hl=en-US&gl=US&ceid=US:en"
        
        return self.fetch_rss_feed(rss_url, query, max_results)
    
    def generate_mock_articles(self, category: str, count: int = 5) -> List[NewsArticle]:
        """Generate mock articles for testing"""
        
        if not self.config.mock_mode:
            return []
        
        self.logger.info(f"üé≠ Generating {count} mock articles for: {category}")
        
        mock_templates = [
            {
                'title': f'Breaking: Major Development in {category.title()}',
                'summary': f'Recent developments in {category} show significant changes that could impact global markets and policy decisions.',
                'source': 'Mock News Network'
            },
            {
                'title': f'{category.title()} Trends Show Positive Growth',
                'summary': f'Analysis of current {category} trends indicates sustained growth and positive outlook for the coming months.',
                'source': 'Global Analysis Today'
            },
            {
                'title': f'Expert Commentary on {category.title()} Developments',
                'summary': f'Leading experts weigh in on recent {category} developments and their potential implications.',
                'source': 'Expert Insights'
            }
        ]
        
        articles = []
        for i in range(min(count, len(mock_templates))):
            template = mock_templates[i]
            
            article = NewsArticle(
                title=template['title'],
                summary=template['summary'],
                url=f"https://mock-news.com/article-{i+1}",
                published_date=datetime.now().isoformat(),
                source=template['source'],
                category=category,
                content=f"Full content for {template['title']}..."
            )
            
            articles.append(article)
        
        return articles
    
    def fetch_trending_news(self) -> List[NewsArticle]:
        """Fetch trending news from all configured sources"""
        
        with LogOperation("Fetch trending news", self.logger):
            all_articles = []
            
            # Fetch from each configured category
            for category in self.config.news_categories:
                category_articles = []
                
                # Try GNews first
                if self.config.news_api_key:
                    gnews_articles = self.fetch_gnews(category, max_results=3)
                    category_articles.extend(gnews_articles)
                
                # Fallback to Google News RSS if needed
                if len(category_articles) < 2:
                    rss_articles = self.fetch_google_news_rss(category, max_results=3)
                    category_articles.extend(rss_articles)
                
                # Use mock articles if still not enough and mock mode enabled
                if len(category_articles) < 1 and self.config.mock_mode:
                    mock_articles = self.generate_mock_articles(category, count=2)
                    category_articles.extend(mock_articles)
                
                all_articles.extend(category_articles)
            
            # Remove duplicates based on title similarity
            unique_articles = self._deduplicate_articles(all_articles)
            
            # Limit to max articles
            final_articles = unique_articles[:self.config.max_articles]
            
            self.logger.info(f"üì∞ Total articles fetched: {len(final_articles)}", extra_data={
                'total_fetched': len(all_articles),
                'after_deduplication': len(unique_articles),
                'final_count': len(final_articles),
                'categories': self.config.news_categories
            })
            
            return final_articles
    
    def _deduplicate_articles(self, articles: List[NewsArticle]) -> List[NewsArticle]:
        """Remove duplicate articles based on title similarity"""
        
        unique_articles = []
        seen_titles = set()
        
        for article in articles:
            # Simple deduplication based on title
            title_words = set(article.title.lower().split())
            
            is_duplicate = False
            for seen_title in seen_titles:
                seen_words = set(seen_title.split())
                
                # If 70% of words match, consider it a duplicate
                if len(title_words & seen_words) / len(title_words | seen_words) > 0.7:
                    is_duplicate = True
                    break
            
            if not is_duplicate:
                unique_articles.append(article)
                seen_titles.add(article.title.lower())
        
        removed_count = len(articles) - len(unique_articles)
        if removed_count > 0:
            self.logger.info(f"üîÑ Removed {removed_count} duplicate articles")
        
        return unique_articles
    
    def save_articles_cache(self, articles: List[NewsArticle], cache_file: str = None) -> str:
        """Save articles to cache file"""
        
        if not cache_file:
            cache_file = f"news_cache_{datetime.now().strftime('%Y-%m-%d')}.json"
        
        cache_data = {
            'timestamp': datetime.now().isoformat(),
            'count': len(articles),
            'articles': [article.to_dict() for article in articles]
        }
        
        with open(cache_file, 'w', encoding='utf-8') as f:
            json.dump(cache_data, f, indent=2, ensure_ascii=False)
        
        self.logger.info(f"üíæ Articles cached to: {cache_file}")
        return cache_file
    
    def load_articles_cache(self, cache_file: str) -> List[NewsArticle]:
        """Load articles from cache file"""
        
        try:
            with open(cache_file, 'r', encoding='utf-8') as f:
                cache_data = json.load(f)
            
            articles = []
            for article_data in cache_data.get('articles', []):
                article = NewsArticle(**article_data)
                articles.append(article)
            
            self.logger.info(f"üìÇ Loaded {len(articles)} articles from cache: {cache_file}")
            return articles
            
        except Exception as e:
            self.logger.error(f"‚ùå Error loading cache file {cache_file}: {e}")
            return []

=== FILE: claud_agent/blog_writer.py ===
"""
NOOBIE AI Blog Writer
====================

Advanced AI-powered blog generation using Claude and OpenAI APIs
with intelligent content structuring and SEO optimization.
"""

import requests
import json
import time
from datetime import datetime
from typing import List, Dict, Any, Optional
from dataclasses import dataclass
import re

from .logger import get_logger, LogOperation
from .config import NoobieConfig
from .news_fetcher import NewsArticle

@dataclass
class BlogPost:
    """Data class for generated blog posts"""
    title: str
    content: str
    summary: str
    tags: List[str]
    category: str
    publication_date: str
    author: str
    word_count: int
    seo_title: Optional[str] = None
    seo_description: Optional[str] = None
    featured_image: Optional[str] = None
    
    def to_markdown(self) -> str:
        """Convert blog post to markdown with frontmatter"""
        
        # Create frontmatter
        frontmatter = f"""---
layout: post
title: "{self.title}"
date: {self.publication_date}
author: "{self.author}"
categories: [{self.category}]
tags: [{', '.join(f'"{tag}"' for tag in self.tags)}]
excerpt: "{self.summary}"
seo_title: "{self.seo_title or self.title}"
seo_description: "{self.seo_description or self.summary}"
word_count: {self.word_count}
---

"""
        
        return frontmatter + self.content
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert blog post to dictionary"""
        return {
            'title': self.title,
            'content': self.content,
            'summary': self.summary,
            'tags': self.tags,
            'category': self.category,
            'publication_date': self.publication_date,
            'author': self.author,
            'word_count': self.word_count,
            'seo_title': self.seo_title,
            'seo_description': self.seo_description,
            'featured_image': self.featured_image
        }

class BlogWriter:
    """
    Advanced AI blog writer with multiple model support and intelligent content generation
    """
    
    def __init__(self, config: NoobieConfig):
        self.config = config
        self.logger = get_logger(__name__)
        
        # AI API endpoints
        self.claude_api_url = "https://api.anthropic.com/v1/messages"
        self.openai_api_url = "https://api.openai.com/v1/chat/completions"
        
        # Content templates
        self.system_prompt = self._load_system_prompt()
        
    def _load_system_prompt(self) -> str:
        """Load the system prompt for AI content generation"""
        
        default_prompt = f"""You are NOOBIE AI, an intelligent blog writer that creates thoughtful, engaging daily blog posts about global news and trends.

Your writing style:
- Professional yet accessible tone
- Analytical and insightful commentary
- Well-structured with clear headings
- SEO-optimized content
- Engaging introduction and conclusion
- Use of relevant examples and context

Blog specifications:
- Target audience: Educated readers interested in global affairs
- Word count: 800-1500 words
- Include 3-5 main sections with subheadings
- Add relevant tags and categories
- Create compelling headlines
- Focus on analysis rather than just reporting

Author: {self.config.author_name}
Blog: {self.config.blog_title}

Always maintain objectivity while providing thoughtful analysis of current events."""

        return default_prompt
    
    def _create_content_prompt(self, articles: List[NewsArticle]) -> str:
        """Create the content generation prompt from articles"""
        
        articles_text = "\n\n".join([
            f"**Article {i+1}:**\n"
            f"Title: {article.title}\n"
            f"Source: {article.source}\n"
            f"Summary: {article.summary}\n"
            f"Category: {article.category}\n"
            f"URL: {article.url}"
            for i, article in enumerate(articles)
        ])
        
        current_date = datetime.now().strftime("%B %d, %Y")
        
        prompt = f"""Based on the following news articles from {current_date}, create a comprehensive blog post that analyzes the key themes and developments:

{articles_text}

Please create a blog post with:
1. A compelling title that captures the main themes
2. An engaging introduction
3. 3-4 main sections with descriptive subheadings
4. Thoughtful analysis connecting the different stories
5. A conclusion that looks forward to implications
6. Appropriate tags and categories

The blog post should be informative, well-researched, and provide unique insights beyond just summarizing the news. Focus on connecting themes across different stories and providing valuable analysis for readers interested in understanding global developments.

Format the response as a complete blog post in markdown format."""

        return prompt
    
    def _call_claude_api(self, prompt: str) -> Optional[str]:
        """Call Claude API for content generation"""
        
        if not self.config.claude_api_key:
            self.logger.warning("üîë Claude API key not configured")
            return None
        
        with LogOperation("Claude API call", self.logger):
            headers = {
                "Content-Type": "application/json",
                "x-api-key": self.config.claude_api_key,
                "anthropic-version": "2023-06-01"
            }
            
            payload = {
                "model": "claude-3-sonnet-20240229",
                "max_tokens": 4000,
                "temperature": 0.7,
                "system": self.system_prompt,
                "messages": [
                    {
                        "role": "user",
                        "content": prompt
                    }
                ]
            }
            
            try:
                response = requests.post(
                    self.claude_api_url,
                    headers=headers,
                    json=payload,
                    timeout=120
                )
                
                response.raise_for_status()
                data = response.json()
                
                if 'content' in data and data['content']:
                    content = data['content'][0].get('text', '')
                    self.logger.info(f"‚úÖ Claude API response received ({len(content)} characters)")
                    return content
                else:
                    self.logger.error("‚ùå Invalid response format from Claude API")
                    return None
                    
            except requests.exceptions.RequestException as e:
                self.logger.error(f"‚ùå Claude API request failed: {e}")
                return None
            except Exception as e:
                self.logger.error(f"‚ùå Error processing Claude API response: {e}")
                return None
    
    def _call_openai_api(self, prompt: str) -> Optional[str]:
        """Call OpenAI API as fallback"""
        
        if not self.config.openai_api_key:
            self.logger.warning("üîë OpenAI API key not configured")
            return None
        
        with LogOperation("OpenAI API call", self.logger):
            headers = {
                "Content-Type": "application/json",
                "Authorization": f"Bearer {self.config.openai_api_key}"
            }
            
            payload = {
                "model": "gpt-4",
                "messages": [
                    {"role": "system", "content": self.system_prompt},
                    {"role": "user", "content": prompt}
                ],
                "max_tokens": 4000,
                "temperature": 0.7
            }
            
            try:
                response = requests.post(
                    self.openai_api_url,
                    headers=headers,
                    json=payload,
                    timeout=120
                )
                
                response.raise_for_status()
                data = response.json()
                
                if 'choices' in data and data['choices']:
                    content = data['choices'][0]['message']['content']
                    self.logger.info(f"‚úÖ OpenAI API response received ({len(content)} characters)")
                    return content
                else:
                    self.logger.error("‚ùå Invalid response format from OpenAI API")
                    return None
                    
            except requests.exceptions.RequestException as e:
                self.logger.error(f"‚ùå OpenAI API request failed: {e}")
                return None
            except Exception as e:
                self.logger.error(f"‚ùå Error processing OpenAI API response: {e}")
                return None
    
    def _generate_mock_content(self, articles: List[NewsArticle]) -> str:
        """Generate mock content for testing"""
        
        current_date = datetime.now().strftime("%B %d, %Y")
        categories = list(set(article.category for article in articles))
        
        mock_content = f"""# Today's Global Pulse - {current_date}

*Generated by NOOBIE AI - Your Daily News Intelligence System*

## Executive Summary

In examining today's global developments, several key themes emerge that deserve thoughtful analysis. Our AI system has analyzed {len(articles)} articles across {len(categories)} categories to bring you this comprehensive overview.

## Political Developments

Recent political developments continue to shape the international landscape. The interconnected nature of global politics means that decisions in one region often have far-reaching implications across multiple continents.

### Key Political Trends

- International diplomatic initiatives show continued engagement
- Policy decisions reflect growing focus on economic security
- Regional cooperation efforts demonstrate multilateral approaches

## Economic Indicators

Global markets continue to demonstrate resilience in the face of various challenges. Current economic indicators suggest a complex but generally positive outlook for sustained growth.

### Market Analysis

The current economic environment rewards adaptability and innovation. Organizations that can balance efficiency with resilience appear best positioned for long-term success.

## Technology and Innovation

The pace of technological advancement continues to accelerate, with artificial intelligence and automation reshaping industries globally. Today's developments highlight both tremendous opportunities and important responsibilities.

### AI Integration Trends

As AI systems like NOOBIE AI become more capable of generating thoughtful analysis, we're reminded that technology's greatest value lies in augmenting human judgment rather than replacing it.

## International Affairs

Regional developments across different continents continue to influence global dynamics. From diplomatic initiatives to economic partnerships, today's international landscape reflects both challenges and opportunities.

### Global Cooperation

The most successful international initiatives appear to be those that recognize both national sovereignty and the benefits of collaborative problem-solving.

## Looking Forward

As we analyze today's developments through our AI lens, several patterns emerge that may offer insights into future trends:

1. **Technological Integration**: Seamless AI incorporation continues to accelerate
2. **Economic Adaptation**: Markets show remarkable flexibility and innovation
3. **Global Cooperation**: Evidence of continued international collaboration
4. **Information Analysis**: AI's growing role in processing and presenting complex information

## Conclusion

Today's analysis reinforces the importance of staying informed about global developments while maintaining perspective on long-term trends. NOOBIE AI will continue providing daily insights to help navigate our complex world.

---

**About NOOBIE AI**: This post was generated by an advanced artificial intelligence system designed to analyze global news and provide thoughtful daily commentary.

*Next update: Tomorrow at 8:00 AM UTC*"""

        self.logger.info("üé≠ Generated mock blog content for testing")
        return mock_content
    
    def generate_blog_post(self, articles: List[NewsArticle]) -> Optional[BlogPost]:
        """Generate a complete blog post from news articles"""
        
        if not articles:
            self.logger.error("‚ùå No articles provided for blog generation")
            return None
        
        with LogOperation(f"Blog generation from {len(articles)} articles", self.logger):
            
            # Create content prompt
            content_prompt = self._create_content_prompt(articles)
            
            # Try to generate content with AI APIs
            blog_content = None
            
            # Try Claude first
            if self.config.claude_api_key:
                blog_content = self._call_claude_api(content_prompt)
            
            # Fallback to OpenAI
            if not blog_content and self.config.openai_api_key:
                self.logger.info("üîÑ Falling back to OpenAI API")
                blog_content = self._call_openai_api(content_prompt)
            
            # Fallback to mock content
            if not blog_content:
                self.logger.warning("üé≠ Using mock content generation")
                blog_content = self._generate_mock_content(articles)
            
            if not blog_content:
                self.logger.error("‚ùå Failed to generate blog content")
                return None
            
            # Parse and structure the blog post
            blog_post = self._parse_blog_content(blog_content, articles)
            
            self.logger.info(f"‚úÖ Blog post generated successfully", extra_data={
                'title': blog_post.title,
                'word_count': blog_post.word_count,
                'tags': blog_post.tags,
                'category': blog_post.category
            })
            
            return blog_post
    
    def _parse_blog_content(self, content: str, source_articles: List[NewsArticle]) -> BlogPost:
        """Parse AI-generated content into structured blog post"""
        
        # Extract title (usually the first # heading)
        title_match = re.search(r'#\s+(.+)', content)
        title = title_match.group(1).strip() if title_match else f"Daily Global Analysis - {datetime.now().strftime('%B %d, %Y')}"
        
        # Generate summary from first paragraph
        paragraphs = [p.strip() for p in content.split('\n\n') if p.strip() and not p.startswith('#')]
        summary = paragraphs[0][:200] + "..." if paragraphs else "Daily AI-powered analysis of global news and trends."
        
        # Extract categories from source articles
        categories = list(set(article.category for article in source_articles))
        primary_category = categories[0] if categories else "global-news"
        
        # Generate tags
        tags = self._generate_tags(content, source_articles)
        
        # Calculate word count
        word_count = len(content.split())
        
        # Generate SEO elements
        seo_title = f"{title} | {self.config.blog_title}"
        seo_description = summary[:155] + "..." if len(summary) > 155 else summary
        
        blog_post = BlogPost(
            title=title,
            content=content,
            summary=summary,
            tags=tags,
            category=primary_category,
            publication_date=datetime.now().isoformat(),
            author=self.config.author_name,
            word_count=word_count,
            seo_title=seo_title,
            seo_description=seo_description
        )
        
        return blog_post
    
    def _generate_tags(self, content: str, articles: List[NewsArticle]) -> List[str]:
        """Generate relevant tags from content and source articles"""
        
        # Base tags
        tags = ["daily-update", "ai-generated", "global-news", "analysis"]
        
        # Add category-based tags
        for article in articles:
            category_words = article.category.lower().split()
            tags.extend(category_words)
        
        # Add content-based tags
        content_lower = content.lower()
        
        # Common topic keywords
        topic_keywords = {
            'politics': ['political', 'government', 'policy', 'election'],
            'economics': ['economic', 'market', 'financial', 'trade'],
            'technology': ['technology', 'ai', 'digital', 'innovation'],
            'international': ['international', 'global', 'world', 'diplomatic'],
            'business': ['business', 'corporate', 'industry', 'company']
        }
        
        for tag, keywords in topic_keywords.items():
            if any(keyword in content_lower for keyword in keywords):
                tags.append(tag)
        
        # Remove duplicates and limit
        unique_tags = list(set(tags))[:10]
        
        return unique_tags
    
    def save_blog_post(self, blog_post: BlogPost, output_dir: str = "blog_output") -> str:
        """Save blog post to file"""
        
        from pathlib import Path
        
        # Create output directory
        output_path = Path(output_dir)
        output_path.mkdir(exist_ok=True)
        
        # Generate filename
        date_str = datetime.now().strftime("%Y-%m-%d")
        title_slug = re.sub(r'[^\w\s-]', '', blog_post.title.lower())
        title_slug = re.sub(r'[\s_-]+', '-', title_slug)[:50]
        filename = f"{date_str}-{title_slug}.md"
        
        file_path = output_path / filename
        
        # Save as markdown
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(blog_post.to_markdown())
        
        self.logger.info(f"üíæ Blog post saved to: {file_path}")
        
        # Also save as JSON for backup
        json_path = output_path / f"{date_str}-{title_slug}.json"
        with open(json_path, 'w', encoding='utf-8') as f:
            json.dump(blog_post.to_dict(), f, indent=2, ensure_ascii=False)
        
        return str(file_path)

=== FILE: claud_agent/github_publisher.py ===
"""
NOOBIE AI GitHub Publisher
=========================

Advanced GitHub Pages publishing with automatic commit, push,
and Jekyll optimization for professional blog deployment.
"""

import requests
import base64
import json
from datetime import datetime
from typing import Dict, Any, Optional, List
from dataclasses import dataclass
from pathlib import Path

from .logger import get_logger, LogOperation
from .config import NoobieConfig
from .blog_writer import BlogPost

@dataclass
class PublishResult:
    """Result of publishing operation"""
    success: bool
    message: str
    url: Optional[str] = None
    commit_sha: Optional[str] = None
    errors: List[str] = None
    
    def __post_init__(self):
        if self.errors is None:
            self.errors = []

class GitHubPublisher:
    """
    Advanced GitHub Pages publisher with Jekyll optimization
    """
    
    def __init__(self, config: NoobieConfig):
        self.config = config
        self.logger = get_logger(__name__)
        
        # GitHub API settings
        self.api_base_url = "https://api.github.com"
        self.session = requests.Session()
        
        if config.github_token:
            self.session.headers.update({
                "Authorization": f"token {config.github_token}",
                "Accept": "application/vnd.github.v3+json",
                "User-Agent": "NOOBIE-AI/1.0"
            })
    
    def _make_api_request(self, method: str, endpoint: str, data: Dict[str, Any] = None) -> Optional[Dict[str, Any]]:
        """Make authenticated GitHub API request"""
        
        url = f"{self.api_base_url}{endpoint}"
        
        try:
            if method.upper() == 'GET':
                response = self.session.get(url)
            elif method.upper() == 'POST':
                response = self.session.post(url, json=data)
            elif method.upper() == 'PUT':
                response = self.session.put(url, json=data)
            elif method.upper() == 'DELETE':
                response = self.session.delete(url)
            else:
                raise ValueError(f"Unsupported HTTP method: {method}")
            
            response.raise_for_status()
            return response.json() if response.content else {}
            
        except requests.exceptions.RequestException as e:
            self.logger.error(f"‚ùå GitHub API request failed: {e}")
            if hasattr(e, 'response') and e.response is not None:
                self.logger.error(f"Response: {e.response.text}")
            return None
    
    def _get_file_content(self, file_path: str) -> Optional[Dict[str, Any]]:
        """Get existing file content from repository"""
        
        endpoint = f"/repos/{self.config.github_repo}/contents/{file_path}"
        
        self.logger.debug(f"Getting file content: {file_path}")
        
        response = self._make_api_request('GET', endpoint)
        return response
    
    def _create_or_update_file(self, file_path: str, content: str, message: str, sha: Optional[str] = None) -> Optional[Dict[str, Any]]:
        """Create or update file in repository"""
        
        endpoint = f"/repos/{self.config.github_repo}/contents/{file_path}"
        
        # Encode content to base64
        content_encoded = base64.b64encode(content.encode('utf-8')).decode('utf-8')
        
        data = {
            "message": message,
            "content": content_encoded,
            "branch": self.config.github_branch
        }
        
        # Add SHA if updating existing file
        if sha:
            data["sha"] = sha
        
        self.logger.debug(f"{'Updating' if sha else 'Creating'} file: {file_path}")
        
        return self._make_api_request('PUT', endpoint, data)
    
    def _generate_jekyll_frontmatter(self, blog_post: BlogPost) -> str:
        """Generate Jekyll-compatible frontmatter"""
        
        frontmatter = f"""---
layout: post
title: "{blog_post.title.replace('"', '\\"')}"
date: {blog_post.publication_date}
author: "{blog_post.author}"
categories: [{blog_post.category}]
tags: [{', '.join(f'"{tag}"' for tag in blog_post.tags)}]
excerpt: "{blog_post.summary.replace('"', '\\"')[:200]}..."
seo:
  title: "{blog_post.seo_title or blog_post.title}"
  description: "{blog_post.seo_description or blog_post.summary[:155]}"
  type: article
word_count: {blog_post.word_count}
reading_time: {max(1, blog_post.word_count // 200)}
published: true
featured: false
comments: true
---

"""
        return frontmatter
    
    def _create_post_filename(self, blog_post: BlogPost) -> str:
        """Create Jekyll-compatible post filename"""
        
        # Extract date from publication_date
        pub_date = datetime.fromisoformat(blog_post.publication_date.replace('Z', '+00:00'))
        date_str = pub_date.strftime("%Y-%m-%d")
        
        # Create slug from title
        import re
        slug = re.sub(r'[^\w\s-]', '', blog_post.title.lower())
        slug = re.sub(r'[\s_-]+', '-', slug)[:50].strip('-')
        
        return f"_posts/{date_str}-{slug}.md"
    
    def publish_blog_post(self, blog_post: BlogPost) -> PublishResult:
        """Publish blog post to GitHub Pages"""
        
        if not self.config.github_token:
            return PublishResult(
                success=False,
                message="GitHub token not configured",
                errors=["GITHUB_TOKEN environment variable is required"]
            )
        
        with LogOperation(f"Publish blog post: {blog_post.title}", self.logger):
            
            try:
                # Generate Jekyll-compatible content
                frontmatter = self._generate_jekyll_frontmatter(blog_post)
                full_content = frontmatter + blog_post.content
                
                # Create filename
                filename = self._create_post_filename(blog_post)
                
                # Check if file already exists
                existing_file = self._get_file_content(filename)
                sha = existing_file.get('sha') if existing_file else None
                
                # Create commit message
                action = "Update" if sha else "Add"
                commit_message = f"{action} blog post: {blog_post.title}\n\nGenerated by NOOBIE AI\nTimestamp: {datetime.now().isoformat()}\nWord count: {blog_post.word_count}"
                
                # Upload file
                result = self._create_or_update_file(filename, full_content, commit_message, sha)
                
                if result:
                    # Generate URLs
                    repo_url = f"https://github.com/{self.config.github_repo}/blob/{self.config.github_branch}/{filename}"
                    pages_url = self._generate_pages_url(blog_post)
                    
                    self.logger.info(f"‚úÖ Blog post published successfully", extra_data={
                        'filename': filename,
                        'commit_sha': result.get('commit', {}).get('sha'),
                        'repo_url': repo_url,
                        'pages_url': pages_url
                    })
                    
                    return PublishResult(
                        success=True,
                        message=f"Successfully published: {blog_post.title}",
                        url=pages_url,
                        commit_sha=result.get('commit', {}).get('sha')
                    )
                else:
                    return PublishResult(
                        success=False,
                        message="Failed to upload file to GitHub",
                        errors=["GitHub API request failed"]
                    )
                    
            except Exception as e:
                self.logger.error(f"‚ùå Error publishing blog post: {e}")
                return PublishResult(
                    success=False,
                    message=f"Publishing failed: {str(e)}",
                    errors=[str(e)]
                )
    
    def _generate_pages_url(self, blog_post: BlogPost) -> str:
        """Generate GitHub Pages URL for the blog post"""
        
        # Extract date from publication_date
        pub_date = datetime.fromisoformat(blog_post.publication_date.replace('Z', '+00:00'))
        
        # Create slug from title
        import re
        slug = re.sub(r'[^\w\s-]', '', blog_post.title.lower())
        slug = re.sub(r'[\s_-]+', '-', slug)[:50].strip('-')
        
        # Standard GitHub Pages URL structure
        username = self.config.github_repo.split('/')[0]
        repo_name = self.config.github_repo.split('/')[1]
        
        # Check if it's a user/organization page or project page
        if repo_name.lower() == f"{username.lower()}.github.io":
            # User/organization page
            base_url = f"https://{username.lower()}.github.io"
        else:
            # Project page
            base_url = f"https://{username.lower()}.github.io/{repo_name}"
        
        url_path = f"/{pub_date.year:04d}/{pub_date.month:02d}/{pub_date.day:02d}/{slug}/"
        
        return base_url + url_path
    
    def setup_jekyll_config(self) -> PublishResult:
        """Setup Jekyll configuration for the blog"""
        
        with LogOperation("Setup Jekyll configuration", self.logger):
            
            # Jekyll _config.yml content
            config_content = f"""# NOOBIE AI Blog Configuration
title: "{self.config.blog_title}"
description: "{self.config.blog_description}"
url: "https://{self.config.github_repo.split('/')[0].lower()}.github.io"
baseurl: ""

# Author information
author:
  name: "{self.config.author_name}"
  bio: "AI-powered daily news analysis and global insights"
  avatar: "/assets/images/noobie-avatar.png"

# Social links
github_username: {self.config.github_repo.split('/')[0]}

# Build settings
markdown: kramdown
highlighter: rouge
permalink: /:year/:month/:day/:title/

# Theme
theme: minima

# Plugins
plugins:
  - jekyll-feed
  - jekyll-sitemap
  - jekyll-seo-tag
  - jekyll-paginate

# Pagination
paginate: 10
paginate_path: "/page:num/"

# SEO
seo:
  title: "{self.config.blog_title}"
  description: "{self.config.blog_description}"
  keywords: "AI, blog, news, analysis, artificial intelligence, global news, automated blogging"

# Timezone
timezone: UTC

# Collections
collections:
  posts:
    output: true
    permalink: /:year/:month/:day/:title/

# Defaults
defaults:
  - scope:
      path: ""
      type: "posts"
    values:
      layout: "post"
      author: "{self.config.author_name}"
      show_excerpts: true

# Exclude
exclude:
  - Gemfile
  - Gemfile.lock
  - node_modules
  - vendor/bundle/
  - vendor/cache/
  - vendor/gems/
  - vendor/ruby/
"""
            
            try:
                # Check if _config.yml exists
                existing_config = self._get_file_content("_config.yml")
                sha = existing_config.get('sha') if existing_config else None
                
                # Upload configuration
                result = self._create_or_update_file(
                    "_config.yml",
                    config_content,
                    "Setup Jekyll configuration for NOOBIE AI blog",
                    sha
                )
                
                if result:
                    return PublishResult(
                        success=True,
                        message="Jekyll configuration setup successfully"
                    )
                else:
                    return PublishResult(
                        success=False,
                        message="Failed to setup Jekyll configuration"
                    )
                    
            except Exception as e:
                return PublishResult(
                    success=False,
                    message=f"Error setting up Jekyll config: {str(e)}",
                    errors=[str(e)]
                )
    
    def create_index_page(self) -> PublishResult:
        """Create the main index page for the blog"""
        
        index_content = f"""---
layout: home
title: "{self.config.blog_title}"
description: "{self.config.blog_description}"
---

# Welcome to {self.config.blog_title}

{self.config.blog_description}

## Latest Posts

<div class="post-list">
{{% for post in site.posts limit:5 %}}
  <article class="post-preview">
    <h3><a href="{{{{ post.url }}}}">{{{{ post.title }}}}</a></h3>
    <p class="post-meta">{{{{ post.date | date: "%B %d, %Y" }}}} ‚Ä¢ {{{{ post.reading_time }}}} min read</p>
    <p>{{{{ post.excerpt | strip_html | truncate: 200 }}}}</p>
    <a href="{{{{ post.url }}}}" class="read-more">Read more ‚Üí</a>
  </article>
{{% endfor %}}
</div>

## About NOOBIE AI

NOOBIE AI is an advanced artificial intelligence system that analyzes global news and generates thoughtful daily blog posts. Our AI examines multiple news sources, identifies key themes, and creates insightful commentary that goes beyond simple news reporting.

### What Makes NOOBIE AI Special?

- **ü§ñ AI-Powered Analysis**: Advanced language models process and analyze news from multiple sources
- **üì∞ Daily Updates**: Fresh content generated automatically every morning at 8:00 AM UTC
- **üåç Global Perspective**: Comprehensive coverage of international developments
- **üí° Thoughtful Commentary**: Analysis that provides context and insights

### Latest Statistics

- **Total Posts**: {{{{ site.posts.size }}}}
- **Categories Covered**: Politics, Technology, Economics, International Affairs
- **Average Reading Time**: 5-8 minutes per post
- **Update Frequency**: Daily at 8:00 AM UTC

---

*Powered by artificial intelligence ‚Ä¢ Built with Jekyll ‚Ä¢ Hosted on GitHub Pages*
"""
        
        try:
            existing_index = self._get_file_content("index.md")
            sha = existing_index.get('sha') if existing_index else None
            
            result = self._create_or_update_file(
                "index.md",
                index_content,
                "Create/update blog index page",
                sha
            )
            
            if result:
                return PublishResult(
                    success=True,
                    message="Index page created successfully"
                )
            else:
                return PublishResult(
                    success=False,
                    message="Failed to create index page"
                )
                
        except Exception as e:
            return PublishResult(
                success=False,
                message=f"Error creating index page: {str(e)}",
                errors=[str(e)]
            )
    
    def get_repository_info(self) -> Optional[Dict[str, Any]]:
        """Get repository information"""
        
        endpoint = f"/repos/{self.config.github_repo}"
        return self._make_api_request('GET', endpoint)
    
    def list_recent_posts(self, limit: int = 10) -> List[Dict[str, Any]]:
        """List recent blog posts from the repository"""
        
        endpoint = f"/repos/{self.config.github_repo}/contents/_posts"
        
        response = self._make_api_request('GET', endpoint)
        
        if response and isinstance(response, list):
            # Sort by name (which includes date) and take most recent
            posts = sorted(response, key=lambda x: x['name'], reverse=True)
            return posts[:limit]
        
        return []

=== FILE: azure_function/__init__.py ===
"""
NOOBIE AI Azure Functions
========================

Serverless automation for daily blog generation and publishing.
This package contains the Azure Functions entry points.
"""

__version__ = "1.0.0"
__author__ = "NOOBIE AI Team"
__description__ = "Azure Functions for automated blog generation"

=== FILE: azure_function/function_app.py ===
"""
NOOBIE AI Azure Function App
============================

Main Azure Functions application with timer-triggered daily blog generation
and HTTP-triggered manual operations.
"""

import logging
import azure.functions as func
from datetime import datetime, timezone
import json
import traceback
import os
import sys

# Add parent directory to path for imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from claud_agent.config import load_config
from claud_agent.logger import setup_logging, get_logger, LogOperation
from claud_agent.news_fetcher import NewsFetcher
from claud_agent.blog_writer import BlogWriter
from claud_agent.github_publisher import GitHubPublisher

# Initialize the function app
app = func.FunctionApp()

# Configure logging for Azure
setup_logging(log_level="INFO", enable_console=True, enable_file=False)
logger = get_logger("noobie_ai.azure_function")

@app.timer_trigger(schedule="0 0 8 * * *", arg_name="timer", run_on_startup=False,
                  use_monitor=False) 
def daily_blog_generation(timer: func.TimerRequest) -> None:
    """
    Daily timer-triggered function that runs at 8:00 AM UTC.
    Fetches news, generates blog post, and publishes to GitHub Pages.
    """
    
    with LogOperation("Daily blog generation", logger):
        try:
            logger.info("üöÄ Starting daily blog generation")
            
            # Load configuration
            config = load_config()
            logger.info("üìã Configuration loaded", extra_data=config.to_dict())
            
            # Validate configuration
            validation_errors = config.validate()
            if validation_errors:
                error_msg = f"Configuration validation failed: {validation_errors}"
                logger.error(error_msg)
                raise ValueError(error_msg)
            
            # Initialize components
            news_fetcher = NewsFetcher(config)
            blog_writer = BlogWriter(config)
            github_publisher = GitHubPublisher(config)
            
            # Fetch trending news
            logger.info("üì∞ Fetching trending news articles")
            articles = news_fetcher.fetch_trending_news()
            
            if not articles:
                logger.warning("‚ö†Ô∏è No articles found - using mock mode")
                config.mock_mode = True
                articles = news_fetcher.generate_mock_articles("global-news", count=3)
            
            logger.info(f"‚úÖ Fetched {len(articles)} articles for processing")
            
            # Generate blog post
            logger.info("‚úçÔ∏è Generating blog post from articles")
            blog_post = blog_writer.generate_blog_post(articles)
            
            if not blog_post:
                raise Exception("Failed to generate blog post")
            
            logger.info(f"‚úÖ Blog post generated: '{blog_post.title}' ({blog_post.word_count} words)")
            
            # Setup Jekyll configuration if needed
            logger.info("üèóÔ∏è Setting up Jekyll configuration")
            jekyll_result = github_publisher.setup_jekyll_config()
            if not jekyll_result.success:
                logger.warning(f"Jekyll setup warning: {jekyll_result.message}")
            
            # Create index page
            index_result = github_publisher.create_index_page()
            if not index_result.success:
                logger.warning(f"Index page warning: {index_result.message}")
            
            # Publish to GitHub Pages
            logger.info("üì§ Publishing blog post to GitHub Pages")
            publish_result = github_publisher.publish_blog_post(blog_post)
            
            if publish_result.success:
                logger.info(f"üéâ Blog post published successfully!", extra_data={
                    'title': blog_post.title,
                    'url': publish_result.url,
                    'commit_sha': publish_result.commit_sha,
                    'word_count': blog_post.word_count,
                    'tags': blog_post.tags
                })
            else:
                raise Exception(f"Publishing failed: {publish_result.message}")
            
            # Log execution statistics
            execution_stats = {
                'timestamp': datetime.now(timezone.utc).isoformat(),
                'articles_fetched': len(articles),
                'blog_title': blog_post.title,
                'word_count': blog_post.word_count,
                'tags_count': len(blog_post.tags),
                'publish_url': publish_result.url,
                'success': True
            }
            
            logger.info("üìä Daily blog generation completed successfully", extra_data=execution_stats)
            
        except Exception as e:
            error_msg = f"Daily blog generation failed: {str(e)}"
            logger.error(error_msg, extra_data={
                'error_type': type(e).__name__,
                'error_message': str(e),
                'traceback': traceback.format_exc()
            })
            raise


@app.route(route="manual_generate", auth_level=func.AuthLevel.FUNCTION)
def manual_blog_generation(req: func.HttpRequest) -> func.HttpResponse:
    """
    HTTP-triggered function for manual blog generation.
    Accepts POST requests with optional parameters.
    """
    
    logger.info("üîß Manual blog generation triggered")
    
    try:
        # Parse request parameters
        try:
            req_body = req.get_json() or {}
        except ValueError:
            req_body = {}
        
        # Override configuration if provided
        config = load_config()
        if 'mock_mode' in req_body:
            config.mock_mode = bool(req_body['mock_mode'])
        if 'max_articles' in req_body:
            config.max_articles = int(req_body.get('max_articles', config.max_articles))
        
        logger.info("‚öôÔ∏è Manual generation parameters", extra_data=req_body)
        
        # Run the same logic as daily generation
        news_fetcher = NewsFetcher(config)
        blog_writer = BlogWriter(config)
        github_publisher = GitHubPublisher(config)
        
        # Fetch articles
        articles = news_fetcher.fetch_trending_news()
        if not articles and config.mock_mode:
            articles = news_fetcher.generate_mock_articles("breaking-news", count=3)
        
        if not articles:
            return func.HttpResponse(
                json.dumps({"error": "No articles found"}),
                status_code=400,
                mimetype="application/json"
            )
        
        # Generate blog post
        blog_post = blog_writer.generate_blog_post(articles)
        if not blog_post:
            return func.HttpResponse(
                json.dumps({"error": "Failed to generate blog post"}),
                status_code=500,
                mimetype="application/json"
            )
        
        # Publish
        publish_result = github_publisher.publish_blog_post(blog_post)
        
        response_data = {
            "success": publish_result.success,
            "message": publish_result.message,
            "blog_title": blog_post.title,
            "word_count": blog_post.word_count,
            "url": publish_result.url,
            "commit_sha": publish_result.commit_sha,
            "timestamp": datetime.now(timezone.utc).isoformat()
        }
        
        if publish_result.success:
            logger.info("‚úÖ Manual generation completed successfully", extra_data=response_data)
            return func.HttpResponse(
                json.dumps(response_data),
                status_code=200,
                mimetype="application/json"
            )
        else:
            logger.error("‚ùå Manual generation failed", extra_data=response_data)
            return func.HttpResponse(
                json.dumps(response_data),
                status_code=500,
                mimetype="application/json"
            )
            
    except Exception as e:
        error_response = {
            "success": False,
            "error": str(e),
            "timestamp": datetime.now(timezone.utc).isoformat()
        }
        
        logger.error("‚ùå Manual generation error", extra_data=error_response)
        
        return func.HttpResponse(
            json.dumps(error_response),
            status_code=500,
            mimetype="application/json"
        )


@app.route(route="health", auth_level=func.AuthLevel.ANONYMOUS)
def health_check(req: func.HttpRequest) -> func.HttpResponse:
    """
    Health check endpoint for monitoring.
    """
    
    try:
        config = load_config()
        validation_errors = config.validate()
        
        health_data = {
            "status": "healthy" if not validation_errors else "degraded",
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "version": "1.0.0",
            "configuration": {
                "has_news_api": bool(config.news_api_key),
                "has_claude_api": bool(config.claude_api_key),
                "has_github_token": bool(config.github_token),
                "github_repo": config.github_repo,
                "max_articles": config.max_articles
            },
            "validation_errors": validation_errors
        }
        
        status_code = 200 if not validation_errors else 503
        
        return func.HttpResponse(
            json.dumps(health_data, indent=2),
            status_code=status_code,
            mimetype="application/json"
        )
        
    except Exception as e:
        error_data = {
            "status": "unhealthy",
            "error": str(e),
            "timestamp": datetime.now(timezone.utc).isoformat()
        }
        
        return func.HttpResponse(
            json.dumps(error_data),
            status_code=500,
            mimetype="application/json"
        )


@app.route(route="status", auth_level=func.AuthLevel.FUNCTION)
def get_system_status(req: func.HttpRequest) -> func.HttpResponse:
    """
    Detailed system status endpoint with recent posts information.
    """
    
    try:
        config = load_config()
        github_publisher = GitHubPublisher(config)
        
        # Get repository information
        repo_info = github_publisher.get_repository_info()
        recent_posts = github_publisher.list_recent_posts(limit=5)
        
        status_data = {
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "system_status": "operational",
            "configuration": config.to_dict(),
            "repository": {
                "name": repo_info.get('name') if repo_info else None,
                "full_name": repo_info.get('full_name') if repo_info else None,
                "description": repo_info.get('description') if repo_info else None,
                "homepage": repo_info.get('homepage') if repo_info else None,
                "has_pages": repo_info.get('has_pages') if repo_info else False
            },
            "recent_posts": [
                {
                    "name": post['name'],
                    "size": post['size'],
                    "download_url": post.get('download_url')
                } for post in recent_posts
            ],
            "next_scheduled_run": "Daily at 8:00 AM UTC"
        }
        
        return func.HttpResponse(
            json.dumps(status_data, indent=2),
            status_code=200,
            mimetype="application/json"
        )
        
    except Exception as e:
        error_data = {
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "system_status": "error",
            "error": str(e)
        }
        
        return func.HttpResponse(
            json.dumps(error_data),
            status_code=500,
            mimetype="application/json"
        )

=== FILE: azure_function/requirements.txt ===
# NOOBIE AI Azure Functions Requirements
# ====================================

# Azure Functions Core
azure-functions>=1.18.0
azure-functions-worker>=1.0.0

# Azure SDK
azure-identity>=1.15.0
azure-keyvault-secrets>=4.7.0
azure-storage-blob>=12.19.0

# HTTP and Web
requests>=2.31.0
urllib3>=2.0.7

# Data Processing
feedparser>=6.0.10
python-dateutil>=2.8.2

# AI APIs
anthropic>=0.25.0
openai>=1.12.0

# Utilities
python-dotenv>=1.0.0
pydantic>=2.5.0
typing-extensions>=4.9.0

# Development
pytest>=7.4.0
pytest-asyncio>=0.21.0
black>=23.12.0
flake8>=7.0.0

=== FILE: azure_function/host.json ===
{
  "version": "2.0",
  "logging": {
    "applicationInsights": {
      "samplingSettings": {
        "isEnabled": true,
        "excludedTypes": "Request"
      }
    },
    "logLevel": {
      "default": "Information",
      "Function": "Information",
      "Host.Results": "Information"
    }
  },
  "functionTimeout": "00:10:00",
  "healthMonitor": {
    "enabled": true,
    "healthCheckInterval": "00:00:10",
    "healthCheckWindow": "00:02:00",
    "healthCheckThreshold": 6,
    "counterThreshold": 0.80
  },
  "http": {
    "routePrefix": "api",
    "maxConcurrentRequests": 5,
    "maxOutstandingRequests": 8
  },
  "retry": {
    "strategy": "exponentialBackoff",
    "maxRetryCount": 3,
    "minimumInterval": "00:00:05",
    "maximumInterval": "00:05:00"
  },
  "extensions": {
    "timers": {
      "maxConcurrency": 1
    }
  }
}

=== FILE: azure_function/local.settings.json ===
{
  "IsEncrypted": false,
  "Values": {
    "AzureWebJobsStorage": "UseDevelopmentStorage=true",
    "FUNCTIONS_WORKER_RUNTIME": "python",
    "FUNCTIONS_EXTENSION_VERSION": "~4",
    "PYTHON_ISOLATE_WORKER_DEPENDENCIES": "1",
    "SCM_DO_BUILD_DURING_DEPLOYMENT": "true",
    
    "_COMMENT_API_KEYS": "Add your API keys below for local development",
    "NEWS_API_KEY": "",
    "CLAUDE_API_KEY": "",
    "OPENAI_API_KEY": "",
    "GITHUB_TOKEN": "",
    
    "_COMMENT_CONFIG": "Blog configuration",
    "BLOG_TITLE": "NOOBIE AI - Daily News Intelligence",
    "AUTHOR_NAME": "NOOBIE AI",
    "GITHUB_REPO": "akhilreddydanda/NOOBIE",
    "GITHUB_BRANCH": "main",
    
    "_COMMENT_FEATURES": "Feature flags",
    "MAX_ARTICLES": "8",
    "LOG_LEVEL": "INFO",
    "UPLOAD_TO_GITHUB": "true",
    "MOCK_MODE": "false",
    "RETRY_ATTEMPTS": "3"
  },
  "Host": {
    "LocalHttpPort": 7071,
    "CORS": "*",
    "CORSCredentials": false
  }
}

=== FILE: azure_function/proxies.json ===
{
  "$schema": "http://json.schemastore.org/proxies",
  "proxies": {
    "root": {
      "matchCondition": {
        "route": "/"
      },
      "responseOverrides": {
        "response.statusCode": "200",
        "response.headers.Content-Type": "application/json",
        "response.body": "{\n  \"name\": \"NOOBIE AI Blog Generator\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Automated daily blog generation using AI\",\n  \"author\": \"NOOBIE AI Team\",\n  \"endpoints\": {\n    \"health\": \"/api/health\",\n    \"status\": \"/api/status\",\n    \"manual_generate\": \"/api/manual_generate\"\n  },\n  \"schedule\": \"Daily at 8:00 AM UTC\",\n  \"repository\": \"https://github.com/akhilreddydanda/NOOBIE\",\n  \"documentation\": \"https://github.com/akhilreddydanda/NOOBIE/blob/main/README.md\"\n}"
      }
    }
  }
}

=== FILE: azure_function/.funcignore ===
# Azure Functions ignore file
# ==========================

# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# Virtual environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# IDE files
.vscode/
.idea/
*.swp
*.swo
*~

# OS files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Logs
*.log
logs/

# Test files
.pytest_cache/
.coverage
htmlcov/
.tox/

# Local development
local.settings.json
.azure/

# Cache files
.cache/
blog_output/
news_cache_*.json

# Backup files
*.bak
*.backup

=== FILE: azure_function/.gitignore ===
# Azure Functions specific
.azure/
local.settings.json
.vscode/
bin/
obj/

# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# Virtual environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# IDE
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Logs and cache
*.log
logs/
.cache/
blog_output/
news_cache_*.json

# Test coverage
.coverage
htmlcov/
.pytest_cache/
.tox/

# Secrets
*.key
*.pem
secrets.json
================================
üöÄ FINAL SETUP INSTRUCTIONS:
================================

1. Create new repository at: https://github.com/DandaAkhilReddy/noobie
2. Copy all files above into your repository
3. Update azure_function/local.settings.json with your API keys:
   - NEWS_API_KEY: Get from https://gnews.io
   - CLAUDE_API_KEY: Get from https://console.anthropic.com
   - GITHUB_TOKEN: Create at https://github.com/settings/tokens
   - GITHUB_REPO: Set to "DandaAkhilReddy/noobie"

4. Deploy to Azure:
   - Install Azure CLI: https://docs.microsoft.com/en-us/cli/azure/install-azure-cli
   - Run: chmod +x deploy_azure.sh && ./deploy_azure.sh
   
5. Your system will automatically:
   - Run daily at 8:00 AM UTC
   - Fetch trending news
   - Generate AI blog posts
   - Publish to GitHub Pages

================================
‚úÖ SYSTEM COMPLETE\!
================================

Total files: 17
Production-ready: ‚úÖ
Azure Functions: ‚úÖ
AI-powered: ‚úÖ
Auto-publishing: ‚úÖ

Your NOOBIE AI system is ready to go live\! üéâ
EOF < /dev/null


================================
üöÄ FINAL SETUP INSTRUCTIONS:
================================

1. Create new repository at: https://github.com/DandaAkhilReddy/noobie
2. Copy all files above into your repository
3. Update azure_function/local.settings.json with your API keys:
   - NEWS_API_KEY: Get from https://gnews.io
   - CLAUDE_API_KEY: Get from https://console.anthropic.com
   - GITHUB_TOKEN: Create at https://github.com/settings/tokens
   - GITHUB_REPO: Set to "DandaAkhilReddy/noobie"

4. Deploy to Azure:
   - Install Azure CLI: https://docs.microsoft.com/en-us/cli/azure/install-azure-cli
   - Run: chmod +x deploy_azure.sh && ./deploy_azure.sh
   
5. Your system will automatically:
   - Run daily at 8:00 AM UTC
   - Fetch trending news
   - Generate AI blog posts
   - Publish to GitHub Pages

================================
‚úÖ SYSTEM COMPLETE!
================================

Total files: 17
Production-ready: ‚úÖ
Azure Functions: ‚úÖ
AI-powered: ‚úÖ
Auto-publishing: ‚úÖ

Your NOOBIE AI system is ready to go live! üéâ
